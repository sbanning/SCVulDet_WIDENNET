1 1001.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract HelloWorld {
    string public greeting;
    constructor(string memory _greeting) {
        greeting = _greeting;
    }
    function setGreeting(string memory _newGreeting) public {
        greeting = _newGreeting;
    }
}
0
----------------------------------------
2 1002.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract ERC20Token {
    string public name = "MyToken";
    string public symbol = "MTK";
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    constructor(uint256 initialSupply) {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balanceOf[msg.sender] = totalSupply;
    }

    function transfer(address to, uint256 value) public returns (bool) {
        require(to != address(0), "Invalid address");
        require(balanceOf[msg.sender] >= value, "Insufficient balance");
        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(from != address(0) && to != address(0), "Invalid address");
        require(balanceOf[from] >= value, "Insufficient balance");
        require(allowance[from][msg.sender] >= value, "Allowance exceeded");
        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}
0
----------------------------------------
3 1003.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract Voting {
    mapping(string => uint256) public votes;

    function voteForOption(string memory option) public {
        votes[option]++;
    }

    function getVotesForOption(string memory option) public view returns (uint256) {
        return votes[option];
    }
}
1
----------------------------------------
4 1004.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract Crowdfunding {
    address public owner;
    uint256 public fundingGoal;
    uint256 public totalFunds;

    constructor(uint256 _fundingGoal) {
        owner = msg.sender;
        fundingGoal = _fundingGoal;
    }

    function contribute() public payable {
        require(msg.value > 0, "Contribution must be greater than 0");
        totalFunds += msg.value;
    }

    function releaseFunds() public {
        require(msg.sender == owner, "Only the owner can release funds");
        require(totalFunds >= fundingGoal, "Funding goal not reached");
        payable(owner).transfer(totalFunds);
    }
}
0
----------------------------------------
5 1005.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Auction {
    address public owner;
    address public highestBidder;
    uint256 public highestBid;

    constructor() {
        owner = msg.sender;
    }

    function bid() public payable {
        require(msg.sender != owner, "Owner cannot bid");
        require(msg.value > highestBid, "Bid must be higher than the current highest bid");

        if (highestBidder != address(0)) {
            payable(highestBidder).transfer(highestBid);
        }

        highestBidder = msg.sender;
        highestBid = msg.value;
    }

    function endAuction() public {
        require(msg.sender == owner, "Only the owner can end the auction");
        require(block.timestamp >= 100000, "Auction time has not expired"); // Add a time condition
        payable(owner).transfer(highestBid);
    }
}
1
----------------------------------------
6 1006.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SubscriptionPayment {
    mapping(address => uint256) public subscriptionExpiry;

    function subscribe(uint256 duration) public payable {
        // Subscribe to a service for the specified duration by sending ether
        subscriptionExpiry[msg.sender] = block.timestamp + duration;
    }

    function isSubscribed(address subscriber) public view returns (bool) {
        // Check if a subscriber is currently subscribed
        return subscriptionExpiry[subscriber] >= block.timestamp;
    }
}
0
----------------------------------------
7 1007.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
contract SimpleDAO {
    mapping(address => uint256) public balances;
    function contribute() public payable {
        // Contribute funds to the DAO
        balances[msg.sender] += msg.value;
    }
    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount, "Insufficient balance");
        // Withdraw funds from the DAO
        payable(msg.sender).transfer(amount);
        balances[msg.sender] -= amount;
    }
}
1
----------------------------------------
8 1008.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract DecentralizedIdentity {
    mapping(address => string) public identities;

    function setIdentity(string memory _identity) public {
        // Set or update the decentralized identity for the sender
        identities[msg.sender] = _identity;
    }
}
0
----------------------------------------
9 1009.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleLottery {
    address[] public players;

    function enter() public payable {
        require(msg.value > 0.01 ether, "Minimum entry fee is 0.01 ether");
        // Add player to the lottery
        players.push(msg.sender);
    }

    function pickWinner() public {
        require(msg.sender == address(this), "Only the owner can pick a winner");
        // Randomly select a winner and send them the prize
        address winner = players[random() % players.length];
        payable(winner).transfer(address(this).balance);
        // Reset the players array
        delete players;
    }

    function random() private view returns (uint256) {
        return uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, players)));
    }
}
1
----------------------------------------
10 1010.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract TimeLockedWallet {
    address public owner;
    uint256 public unlockTime;

    constructor(uint256 _unlockTime) {
        owner = msg.sender;
        unlockTime = _unlockTime;
    }

    function withdraw() public {
        require(msg.sender == owner, "Only the owner can withdraw");
        require(block.timestamp >= unlockTime, "Funds are still locked");
        // Withdraw funds
        payable(owner).transfer(address(this).balance);
    }
}
1
----------------------------------------
