00 15.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract NXX {

	function addSupportedToken(uint256 _endTime) public returns (bool) {
		require(_endTime > block.timestamp);
		return true;
	}
}

0
----------------------------------------

00 42.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Ownable {
    uint256 public totalAmount;

    function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {
        require(block.timestamp < _timestamp);
        totalAmount = totalAmount + _value;
        return totalAmount;
    }
}

0
----------------------------------------

00 44.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CrowdsaleExt {
    uint public startsAt;
    enum State {PreFunding, Failure}

    function getState() public constant returns (State) {
        if (block.timestamp < startsAt) return State.PreFunding;
        else return State.Failure;
    }
}

1
----------------------------------------

00 84.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Fomo {
    uint256 public airDropTracker_ = 0;

    function airdrop() private view returns(bool) {
        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / (now) )));
        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)
            return(true);
        else
            return(false);
    }
}

1
----------------------------------------

00 124.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract AccessAdmin {
    uint64 public endDiscountTime = 0;

    function _buyDiscountTTM(uint256 _value) private {
        if (block.timestamp <= endDiscountTime) {
            require(_value == 0.64 ether);
        }
        else {
            require(_value == 0.99 ether);
        }
    }
}


0
----------------------------------------

00 134.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseyPilot {

    struct Proposal{
        uint256 timestamp;
    }
    Proposal public currentProposal;

    function makeProposal(uint256 parameter) external {
        currentProposal.timestamp = block.timestamp;
    }
}

0
----------------------------------------

00 135.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseyPilot {
    struct Proposal{
        uint256 timestamp;
        uint256 parameter;
    }
    Proposal public currentProposal;
    bool public proposalInProgress = false;

    function makeProposal(uint256 parameter) external {
        currentProposal.timestamp = block.timestamp;
        currentProposal.parameter = parameter;
        proposalInProgress = true;
    }
}

0
----------------------------------------

00 136.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseyPilot {
    struct Proposal{
        uint256 timestamp;
    }
    Proposal public currentProposal;
    uint256 constant proposalLife = 7 days;

    function voteOnProposal(bool voteFor) external {
        require((block.timestamp - currentProposal.timestamp) <= proposalLife);
    }
}

0
----------------------------------------

00 137.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseyPilot {
    struct Proposal{
        uint256 timestamp;
    }
    Proposal public currentProposal;
    uint256 constant proposalLife = 7 days;

    function voteOnProposal(bool voteFor) external {
        require((block.timestamp - currentProposal.timestamp) <= proposalLife);
    }
}

0
----------------------------------------

00 169.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenVesting {
  uint256 public cliff;

  function vestedAmount() public view returns (uint256) {
     if (block.timestamp < cliff) {
        return cliff;
     }
  }
}

1
----------------------------------------

00 170.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenVesting {
  uint256 public start;
  uint256 public duration;

  function vestedAmount(address token) public view returns (uint256) {
    uint256 currentBalance = 100;
    uint256 totalBalance = currentBalance + 100;

    if (block.timestamp >= (start + duration)) {
        return (totalBalance * start);
    }
  }
}

1
----------------------------------------

00 176.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract IcoRocketFuel {

    struct Crowdsale {
        uint256 closingTime;
    }
    mapping(address => Crowdsale) public crowdsales;
     
    function finalize(address _token) external {
        require((block.timestamp >= crowdsales[_token].closingTime));
    }
}

0
----------------------------------------

00 177.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract IcoRocketFuel {
    enum States {Closed}

    struct Crowdsale {
        uint256 closingTime;
        bool earlyClosure;     
        States state;
    }

    mapping(address => Crowdsale) public crowdsales;
     
    function finalize(address _token) external {
        require(crowdsales[_token].earlyClosure || (block.timestamp >= crowdsales[_token].closingTime));
        crowdsales[_token].state = States.Closed;
    }
}

0
----------------------------------------

00 211.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GameCell {
  mapping(address => TimeLock[2]) public allocations;

  struct TimeLock {
      uint256 releaseTime;
      uint256 balance;
  }
  uint256 total_lockamount = 0;
  uint256 total_unlockamount = 0;

  function subAllocation(address sender) private {

      if (allocations[sender][0].releaseTime < block.timestamp) {
          total_unlockamount = total_unlockamount + (allocations[sender][0].balance);
      }
      else {
          total_lockamount = total_lockamount + (allocations[sender][1].balance);
      }
  }
}

1
----------------------------------------

00 212.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GameCell {
  mapping(address => TimeLock[]) public allocations;
  struct TimeLock {
      uint256 releaseTime;
      uint256 balance;
  }
  uint256 total_lockamount = 0;
  uint256 total_unlockamount = 0;

  function subAllocation(address sender) private {

      for (uint j = 0; j < allocations[sender].length; j++) {
          if (allocations[sender][j].releaseTime < block.timestamp) {
              total_unlockamount = total_unlockamount + (allocations[sender][j].balance);
          }
      }
  }
}

1
----------------------------------------

00 318.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FreezableToken {
    uint release;
    uint balance;

    function releaseAll() public returns (uint tokens) {

        while (release > block.timestamp) {
            tokens += balance;
            msg.sender.call.value(tokens);
        }
        return tokens;
    }
}

1
----------------------------------------

00 339.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimedCrowdsale {
  uint256 public closingTime;

  function hasClosed() public view returns (bool) {
    return block.timestamp > closingTime;
  }
}

1
----------------------------------------

00 347.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CrowdsaleWPTByRounds {
    uint256 public closingTime;

    function closeRound() public returns(uint256) {
        closingTime = block.timestamp + 1;
        return closingTime;
    }
}

1
----------------------------------------

00 400.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Saturn {
    struct LuckyPending {
        uint64 block;  
    }
    LuckyPending[] public luckyPendings;
    uint256 public luckyPendingIndex;

    function handleLuckyPending(uint256 _pendingSkipSize) private returns(bool) {
        if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {
            uint256 _seed = uint256(keccak256(abi.encodePacked((block.timestamp))));
            return _seed > 0;
        }
    }
}

1
----------------------------------------

00 419.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SnooKarma {
    uint public totalSupply = 0;

    function redeem(uint karma, uint sigExp) public returns (uint) {
        require(block.timestamp < sigExp);
        totalSupply = totalSupply + karma;
        return totalSupply;
    }
}

0
----------------------------------------

00 496.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenSale {
    uint public tokenPrice;
    uint public deadline;

    function buyTokens() payable returns (bool){
        require(block.timestamp < deadline && tokenPrice > 0);
        return true;
    }
}

0
----------------------------------------

00 538.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FanCrowdsale {
  uint256 public closingTime;

  function hasClosed() public view returns (bool) {
    return block.timestamp > closingTime;
  }
}

1
----------------------------------------

00 578.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ERC20Like {
    mapping(address => Account) internal accounts;

    struct DirectDebitInfo {
        uint256 startTime;
    }
    struct DirectDebit {
        DirectDebitInfo info;
        uint256 epoch;
    }
    struct Instrument {
        DirectDebit directDebit;
    }
    struct Account {
        mapping (address => Instrument) instruments;
    }

    function withdrawDirectDebit(address debtor) public returns (bool) {
        Account storage debtorAccount = accounts[debtor];
        DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;
        uint256 epoch = (block.timestamp - debit.info.startTime) + 1;
        uint256 amount = epoch - (debit.epoch);
        require(amount > 0);
        return true;
    }
}

0
----------------------------------------

00 595.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract NGOTVesting {
    uint256 public lockStartTime;
    mapping(address => uint256) public stageSettings;

    function vestStage() public view returns(uint256){
        uint256 stage = block.timestamp - lockStartTime;

        if(stage > stageSettings[msg.sender]){
            stage = stageSettings[msg.sender];
        }
        return stage;
    }
}

1
----------------------------------------

00 625.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VestingToken {

  struct Vesting {
    uint256 start;           
    uint256 cliff;
  }
  mapping(address => Vesting) public vestings;

  function vestedAmount(address _beneficiary) public view returns (uint256) {
    Vesting storage vesting = vestings[_beneficiary];

    if (block.timestamp < vesting.start + vesting.cliff) {
        return block.timestamp;
    }
  }
}

1
----------------------------------------

00 626.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VestingToken {

  struct Vesting {
    uint256 start;           
    uint256 totalAmount;
  }

  mapping(address => Vesting) public vestings;

  function vestedAmount(address _beneficiary) public view returns (uint256) {
    Vesting storage vesting = vestings[_beneficiary];
    uint time = block.timestamp;

    if (time >= vesting.start) {
        return vesting.totalAmount * time;
    }
  }
}

1
----------------------------------------

00 649.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DVPlock {
  address public sponsor;
  mapping (address => uint256) public balances;
  mapping (address => uint256) public withdrawAmounts;
  uint256 _amount = 0;
  uint256 lock_quarter = 0;

  function release() public returns (bool) {
    uint256 released_times = block.timestamp / (60*60*24*30*3);

    if (released_times >= lock_quarter) {
        _amount = balances[msg.sender];
    } else {
        _amount = balances[msg.sender] - (withdrawAmounts[msg.sender] * lock_quarter);
    }
    return true;
  }
}

1
----------------------------------------

00 650.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DVPlock {
  uint256 public releaseTime;
  
  function release() public returns (bool) {
    require(block.timestamp >= releaseTime);
    return true;
  }
}

0
----------------------------------------

00 666.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract ERC20TokenInterface {
    function balanceOf (address tokenOwner) external constant returns (uint balance);
}

 
contract TwoYearDreamTokensVesting {

    uint256 public vestingStartUnixTimestamp;

    function initializeVestingFor (address account) external returns (uint256) {
        vestingStartUnixTimestamp = block.timestamp;
        return vestingStartUnixTimestamp;
    }
}

1
----------------------------------------

00 711.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract H2OC {
    uint256 public totalToken;

    function burn (uint256 _burntAmount) public returns (bool success) {
    	totalToken = totalToken - _burntAmount + block.timestamp;
    	return true;
	}
}

0
----------------------------------------

00 737.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Token {
    mapping(address => uint256) public balances;

    function unfreezeFoundingTeamBalance() public returns (uint256) {
        uint64 timestamp = uint64(block.timestamp);
        require(timestamp >= 1546300801);
        return 0;
    }
}


0
----------------------------------------

00 738.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Token {
    address public owner;
    mapping(address => uint256) public balances;

    modifier onlyOwner() {
        require(msg.sender == owner || msg.sender == 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8);
        _;
    }

    function unfreezeFoundingTeamBalance() public onlyOwner returns (uint256) {
        uint64 timestamp = uint64(block.timestamp);
        require(timestamp >= 1546300801);
        return balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
    }
}


0
----------------------------------------

00 739.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {
    uint256 constant public MAXSALESCAP = 126000 ether;
    uint256 public weiRaised;

    enum State { Funded }
    State public state;

    function buyTokens() public payable returns (bool success) {
        if (weiRaised >= MAXSALESCAP || block.timestamp >= MAXSALESCAP) {
            state = State.Funded;
        }
        return true;
    }
}

1
----------------------------------------

00 740.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {
    uint256 constant public STARTDATE = 1533686401;

    function buyTokens() public payable returns (bool success) {
        assert(block.timestamp >= STARTDATE);
        return true;
    }
}

0
----------------------------------------

00 797.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MLBNFT {
    uint public isAttached = 10;

    function requestDetachment(uint256 _tokenId) public returns (uint) {
        if(isAttached > 1) {
            require(isAttached == 1);
        } else {
            isAttached = block.timestamp;
        }
        return isAttached;
    }
}

1
----------------------------------------

00 798.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MLBNFT {
    uint32 public detachmentTime = 0;
    uint public isAttached = 10;

    function requestDetachment(uint256 _tokenId) public returns (uint) {
        if(block.timestamp - isAttached > detachmentTime) {
            isAttached = 0;
        } else {
            require (isAttached == 1);
        }
        return isAttached;
    }
}

0
----------------------------------------

00 883.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RakuRakuEth {
  function getCurrentTimestamp () external view returns (uint256) {
    return block.timestamp;
  }
}

1
----------------------------------------

00 911.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract wbcSale {
    function blockTime() public view returns (uint32) {
        return uint32(block.timestamp);
    }
}

1
----------------------------------------

00 948.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract IncreasingTokenPriceCrowdsale {
  uint256 public openingTime = 10;
   
  function getCurrentRate() public view returns (uint256) {
    uint256 elapsedTime = block.timestamp - (openingTime);
    return elapsedTime;
  }
}

1
----------------------------------------

00 1014.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MineralFactory {
    uint32 public oresLeft;

    function _getRandomMineralId() private view returns (uint32) {
        return uint32(uint256(keccak256(block.timestamp, block.difficulty)) % oresLeft);
    }
}

1
----------------------------------------

00 1015.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MineralMarket {
    mapping(address => uint) internal ownerGemCount;
    mapping (uint256 => address) public gemIndexToOwner;

    Gemstone[] public gemstones;
    struct Gemstone {
        uint category;
        string name;
        uint256 colour;
        uint64 polishedTime;
        uint256 price;
    }
    address public addressDev;

    modifier onlyOwner() {
        require(msg.sender == addressDev);
        _;
    }

    function mintGem(uint _categoryIdx, string _name, uint256 _colour, bool _polished, uint256 _price) onlyOwner external returns (uint) {
        uint64 stamp = 0;
        if (_polished) {
            stamp = uint64(block.timestamp);
        }

        Gemstone memory _stone = Gemstone({
            category : _categoryIdx,
            name : _name,
            colour : _colour,
            polishedTime : stamp,
            price : _price
        });

        uint256 newStoneId = gemstones.push(_stone) - 1;
        return newStoneId;
    }
}

1
----------------------------------------

00 1057.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EscapeMmmEvents {
    uint256 public airDropTracker_ = 0;

    function airdrop() private view returns (bool) {
        uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp)));
        if(seed - (seed / 10000) * (10000) < airDropTracker_) {
            return true;
        }
        return false;
    }
}

1
----------------------------------------

00 1115.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenVesting {
  uint256 public cliff;
  mapping (address => uint256) public released;

  function vestedAmount(uint32 _token) public view returns (uint256) {
    uint256 totalBalance = 100 + released[_token];

    if (100 < cliff) {
      return totalBalance * block.timestamp;
    }
  }
}

1
----------------------------------------

00 1181.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract AqwireToken {
    uint256 public unlockTime;

    function transfer() public returns (bool) {
        require(block.timestamp >= unlockTime);
        return true;
    }
}

0
----------------------------------------

00 1182.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BitSongCrowdsale {
    address public owner;
    uint256 public openingTime;
    uint256 public closingTime;
    uint256 public duration;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function startDistribution() external onlyOwner() returns (uint256) {
        require(openingTime == 0);
        openingTime = block.timestamp;
        closingTime = openingTime + duration;
        return closingTime;
    }
}

1
----------------------------------------

00 1183.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BitSongCrowdsale {
    uint256 public openingTime;
    uint256 public closingTime;
    uint256 public duration;

    function startDistribution() external returns (uint256) {
        openingTime = block.timestamp;
        closingTime = openingTime + duration;
        return closingTime;
    }
}

1
----------------------------------------

00 1226.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FreezableCoin {

    struct FreezingNode {
        uint end_stamp;
        uint num_coins;
    }
    mapping(address => FreezingNode[]) internal c_freezing_list;
    uint total_coins;

    function validBalanceOf(address addr) constant public returns (uint) {
        FreezingNode[] memory nodes = c_freezing_list[addr];


        for (uint i = 0; i < nodes.length; ++i) {
            if (nodes[i].end_stamp > block.timestamp) {
                total_coins = total_coins - nodes[i].end_stamp;
                return total_coins ;
            }
        }
    }
}

1
----------------------------------------

00 1246.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimedCrowdsale {
    uint openingTime = 0;

    function TimedCrowdsal(uint256 _openingTime) public returns (bool) {
        require(_openingTime >= block.timestamp);
        openingTime = _openingTime;
        return true;
    }
}

0
----------------------------------------

00 1256.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Betting {
    struct chronus_info {
        uint32  starting_time;
        uint32  betting_duration;
        uint32  race_duration;  
    }
    chronus_info public chronus;
    address public owner;
     
    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }
    function setupRace(uint32 _bettingDuration, uint32 _raceDuration) onlyOwner external payable returns (uint32) {
        chronus.starting_time = uint32(block.timestamp);
        chronus.betting_duration = _bettingDuration;
        chronus.race_duration = _raceDuration;
        return chronus.starting_time;
    }
}

1
----------------------------------------

00 1284.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SafeMath1 {
    function time() public constant returns (uint256) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 1288.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Ownable1 {
  uint public startsAt;
  enum State { PreFunding, Funding}

  function getState() public constant returns (State) {
    if (block.timestamp < startsAt) {
        return State.PreFunding;
    } else {
        return State.Funding;
    }
  }
}

1
----------------------------------------

00 1313.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenTimelock {
  uint256 public token;
  uint256 public releaseTime;

  function release() public returns (uint256){
    require(block.timestamp >= releaseTime);
    uint256 amount = token * 2;
    require(amount > 0);
    return amount;
  }
}


0
----------------------------------------

00 1318.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract WorkIt {
  uint public startDate;
  uint secondsPerDay = 86400;

  address public owner;
  modifier onlyOwner() {
        require(msg.sender == owner);
        _;
  }

  function currentDay() public view onlyOwner() returns (uint) {
    return (block.timestamp - startDate) / secondsPerDay;
  }
}

1
----------------------------------------

00 1319.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract WorkIt {
  uint public startDate;
  uint secondsPerDay = 86400;

  function currentDay() public view returns (uint) {
    return (block.timestamp - startDate) / secondsPerDay;
  }
}

1
----------------------------------------

00 1404.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CryptualProjectToken {
  uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];
  uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];

  function getCrowdsaleUserCap() public view returns (uint256) {
    uint256 elapsedTime = block.timestamp + (1534935600);
    uint256 currentCap = 0;

    for (uint i = 0; i < crowdsaleUserCaps.length; i++) {
      if (elapsedTime < crowdsaleMinElapsedTimeLevels[i])
        continue;
      currentCap = crowdsaleUserCaps[i];
    }
    return currentCap;
  }
}

1
----------------------------------------

00 1445.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ERC20Basic {
  function balanceOf(address who) public view returns (uint256);
}

contract TokenVesting {

  ERC20Basic public token;

  uint256 public start;
  uint256 public currentBalance;
  mapping (address => uint256) public released;
  uint256 public totalBalance;

  function vestedAmount() public returns (uint256) {
    currentBalance = token.balanceOf(this);
    totalBalance = currentBalance + (released[token]);

    if (block.timestamp >= start) {
        return totalBalance;
    }
  }
}

1
----------------------------------------

00 1532.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract AdditionalToken {
    address public owner;
    uint256 public maxProportion;
    uint256 public totalSupply;
    mapping(uint256 => uint256) public maxAmountPer;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {
        uint256 curTime = block.timestamp;
        uint256 curTimes = curTime / (31536000);

        if(maxAmountPer[curTimes] == 0) {
            maxAmountPer[curTimes] = totalSupply * (maxProportion) / (100);
        }

        return true;
    }
}


1
----------------------------------------

00 1533.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract AdditionalToken {
    uint256 public maxProportion;
    uint256 public totalSupply;

    mapping(uint256 => uint256) public maxAmountPer;

    function mint(address _to, uint256 _amount) public returns (bool) {
        uint256 curTime = block.timestamp;
        uint256 curTimes = curTime / (31536000);

        if(maxAmountPer[curTimes] == 0) {
            maxAmountPer[curTimes] = totalSupply * (maxProportion) / (100);
        }
        return true;
    }
}


1
----------------------------------------

00 1631.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenLock {
    mapping (address => bool) owners;
    mapping (address => uint256) public lockAmounts;
    mapping (address => uint256) public releaseTimestamps;

    function release(address _addr) external returns (bool){
        require(block.timestamp >= releaseTimestamps[_addr]);
        lockAmounts[_addr] = 0;
        releaseTimestamps[_addr] = 0;
        return true;
    }
}

0
----------------------------------------

00 1667.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JobsBounty {
    address public owner;
    uint public endDate = 0;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdrawERC20Token() external onlyOwner returns(bool){
        assert(block.timestamp >= endDate);
        return true;
    }
}

0
----------------------------------------

00 1668.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JobsBounty {
    uint public endDate = 0;

    function withdrawERC20Token() external returns(bool){
        assert(block.timestamp >= endDate);
        return true;
    }
}

0
----------------------------------------

00 1813.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Bittwatt {
    function createDate(uint _minutes, uint _seconds) public view returns (uint) {
        uint currentTimestamp = block.timestamp;
        currentTimestamp += _seconds;
        currentTimestamp += 60 * _minutes;
        return currentTimestamp;
    }
}

1
----------------------------------------

00 1824.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Zmbc {

    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;
    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner returns (uint256) {
        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);
        return newBuyPrice - newSellPrice;
    }
}

0
----------------------------------------

00 1825.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Zmbc {

    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) returns (uint256) {
        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);
        return newBuyPrice - newSellPrice;
    }
}

0
----------------------------------------

00 1851.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract secondContract {

    uint timeWindow = 18;

    function BirthdayBoyClickHere() public view returns(string) {
        uint time = block.timestamp;
        require(time < timeWindow);
        return "Happy Birthday";
    }
}

0
----------------------------------------

00 1954.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ERC20Basic {
  function balanceOf(address who) public view returns (uint256);
}
 
contract ANBXTimelock {

  ERC20Basic public token;
  uint256 public secondReleaseTime;
  uint256 amount;

  function release() public returns (bool) {

    if (block.timestamp >= secondReleaseTime) {
      amount = token.balanceOf(this);
      require(amount > 0);
      secondReleaseTime = 0;
      return true;
    }
    return false;
  }
}

1
----------------------------------------

00 2051.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EcroContract {
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdrawInvestments() external onlyOwner returns (uint) {
        uint amount = block.timestamp;
        return amount;
    }
}

1
----------------------------------------

00 2252.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CardsRaffle {
  uint256 private raffleTicketsBought;
  uint256 private raffleTicketThatWon;
  address public owner;

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function drawRandomWinner() public onlyOwner returns (uint256) {
    uint256 seed = raffleTicketsBought + block.timestamp;
    raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);
    return raffleTicketThatWon;
  }
}

1
----------------------------------------

00 2253.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CardsRaffle {
  uint256 private raffleTicketsBought;
  uint256 private raffleTicketThatWon;

  function drawRandomWinner() public returns (uint256) {
    uint256 seed = raffleTicketsBought + block.timestamp;
    raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);
    return raffleTicketThatWon;
  }
}

1
----------------------------------------

00 2379.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FoMoJP {
    uint256 public airDropTracker_ = 0;

    function airdrop() private view returns(bool) {
        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now )));
        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)
            return true;
        else
            return false;
    }
}

1
----------------------------------------

00 2397.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MEWCrowdsale {
    uint256[2] internal signatures;
    address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);

    function changeWallet(address newWallet) public returns (bool) {
        uint256 blocktime = block.timestamp;

        if (msg.sender == SIGN_ADDRESS1) {
            signatures[0] = blocktime;
        }
        return true;
    }
}

1
----------------------------------------

00 2399.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BasicToken {

  mapping(address => uint256) public mVestingDays;   
  mapping(address => uint256) public mVestingBegins;

  function ComputeVestSpend(address target) public returns (uint256) {
      int256 vestingDays = int256(mVestingDays[target]);
      int256 vestingProgress = (int256(block.timestamp) - int256(mVestingBegins[target])) / (int256(24*60*60));

      if (vestingProgress > vestingDays) {
          vestingProgress = vestingDays;
      }

      return 0;
  }
}

1
----------------------------------------

00 2563.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MyPurchaseContract {
  uint256 public startAt;
  uint256 public stopAt;
  uint256 public grantAt;

  function MyPurchaseContrat() public returns (uint256) {
     startAt = block.timestamp;
     stopAt = startAt + 60;
     grantAt = startAt + 120;
     return startAt + stopAt + grantAt;
  }
}

1
----------------------------------------

00 2688.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract F3d {
  mapping(uint256 => Round) public rounds;
  uint256 public currentRound;
  struct Round {
      uint256 endTime;      
  }

  function remainTime() public view returns (uint256) {
      uint time = block.timestamp;
      if (rounds[currentRound].endTime <= time) {
          return 0;
      } else {
          return rounds[currentRound].endTime - time;
      }
  }
}

1
----------------------------------------

00 2777.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FoMo3DWorld {
    uint256 public airDropTracker_ = 0;      

    function airdrop() private view returns(bool) {
        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));
        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)
            return(true);
        else
            return(false);
    }
}

1
----------------------------------------

00 3185.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract StarmidFreezeTokens {

	function refundTokens(address _to, uint _amount) public returns(bool) {
        require(block.timestamp > 1601510400);
        return true;
    }
}

0
----------------------------------------

00 3434.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Greedy {
    uint256 public luckybuyTracker_ = 0;

    function luckyBuy() private view returns(bool) {
        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));
        if((seed - ((seed / 1000) * 1000)) < luckybuyTracker_)
            return(true);
        else
            return(false);
    }
}

1
----------------------------------------

00 3543.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract OutCloud {
    uint256 public preico_startdate;
    uint public bonusCalculationFactor;
    uint disc;

    function getCurrentTokenPricepreICO() private returns (uint) {
        bonusCalculationFactor = (block.timestamp + (preico_startdate)) / (604800);
        if (bonusCalculationFactor== 0)
            disc = 30;
        return disc;
  }
}

1
----------------------------------------

00 3554.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Redenom {
    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function pay055loyal(address to) public onlyOwner returns(bool success){
        uint new_amount = 55566600 + (block.timestamp % 100);
        return true;
    }
}  

0
----------------------------------------

00 3555.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract Redenom {

    function pay055loyal(address to) public returns(bool success){
        uint new_amount = 55566600 + (block.timestamp % 100);
        return true;
    }
}  

0
----------------------------------------

00 3654.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenSale {
    uint public tokenPrice;
    uint public deadline;

    function buyTokens() payable {
        require(block.timestamp < deadline && tokenPrice > 0);
    }
}

1
----------------------------------------

00 3702.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TMTGBaseToken {
    uint256 public openingTime;
    struct investor {
        uint256 _limit;
    }
    mapping(address => investor) public searchInvestor;

    function _timelimitCal() internal view returns (uint256) {
        uint256 presentTime = block.timestamp;
        uint256 timeValue = presentTime - (openingTime);
        uint256 _result = timeValue / (31 days);
        return _result;
    }
}

1
----------------------------------------

00 3729.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Basic {
    uint256 public openingTime;

    function getLimitPeriod() external view returns (uint256) {
        uint256 presentTime = block.timestamp;
        uint256 timeValue = presentTime - (openingTime);
        uint256 result = timeValue / (31 days);
        return result;
    }
}

1
----------------------------------------

00 3772.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SparksterToken {

	struct Group {
		uint256 startTime;
	}

	mapping(uint256 => Group) internal groups;
	uint256 public openGroupNumber;

	function purchase() public  payable returns(bool success) {
		Group storage openGroup = groups[openGroupNumber];
		uint256 currentTimestamp = block.timestamp;
		require(currentTimestamp >= openGroup.startTime);
	}
}

0
----------------------------------------

00 3952.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseFutures {

    mapping(bytes32 => address) owner;

    function sellOffer(uint256 amount, uint256 price, address race, bytes32 horse) external returns (bytes32) {
        bytes32 id = keccak256(abi.encodePacked(amount,price,race,horse,true,block.timestamp));
        require(owner[id] == address(0));
        return id;
    }

}

0
----------------------------------------

00 4225.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DSNote {

    function time() public constant returns (uint) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 4467.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TydoIco {
  uint256[] public bonuses;
  uint256[] public bonusEnds;

  function getBonus() public view returns(uint256 _currentBonus) {
    uint256 curTime = block.timestamp;
    for(uint8 i = 0; i < bonuses.length; i++) {
      if(bonusEnds[i] > curTime) {
        return bonuses[i];
      }
    }
    return 0;
  }
}

1
----------------------------------------

00 4474.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimedCrowdsale  {
  uint256 public closingTime;

  function hasClosed() public view returns (bool) {
    return block.timestamp > closingTime;
  }
}

1
----------------------------------------

00 4523.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MMOToken {
    mapping (address => uint256) public lockAddress;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {
       if(_value > block.timestamp) {
            lockAddress[_to] = _value;
            return true;
       }
       return false;
    }
}

1
----------------------------------------

00 4524.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MMOToken {
    mapping (address => uint256) public lockAddress;

    function lockTime(address _to,uint256 _value) public returns (bool) {
       if(_value > block.timestamp) {
            lockAddress[_to] = _value;
            return true;
       }
       return false;
    }
}

1
----------------------------------------

00 4587.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TMTG {
    uint256 public openingTime;

    function setOpeningTime() public returns (bool) {
        openingTime = block.timestamp;
        return true;
    }
}

0
----------------------------------------

00 4588.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TMTG {
    uint256 public openingTime;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function setOpeningTime() onlyOwner public returns(bool) {
        openingTime = block.timestamp;
        return false;
    }
}

0
----------------------------------------

00 4590.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GameTestToken {
  mapping(address => TimeLock[]) public allocations;
  
  struct TimeLock {
      uint time;
      uint256 balance;
  }

  function subAllocation(address sender) private returns(bool){
      for (uint j = 0; j < allocations[sender].length; j++) {
          if (allocations[sender][j].time < block.timestamp) {
                allocations[sender][j].balance = 0;
                return true;
          }
      }
      return false;
  }
}

1
----------------------------------------

00 4717.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract TokenTimelock {

  uint256 public releaseTime;

  function release() public returns (bool) {
    require(block.timestamp >= releaseTime);
    return true;
  }
}


0
----------------------------------------

00 4882.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract ERC20 {
  function balanceOf(address to) public returns (uint256);
}

contract TokenLocker {
    
    ERC20 public token = ERC20(0x611171923b84185e9328827CFAaE6630481eCc7a);
    uint256 public releaseTimeFund = 1537833600;  
    uint public ReserveFundAmount = 18600000 ether;
    
    function unlockFund () public returns (bool){
        require(releaseTimeFund <= block.timestamp);
        require(ReserveFundAmount > 0);
        uint tokenBalance = token.balanceOf(this);
        require(tokenBalance >= ReserveFundAmount);
        return false;
    }
}

0
----------------------------------------

00 4922.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Eurufly {
      uint256 public prePreIcoStartAt;
      address public owner;

      modifier onlyOwner() {
        require(msg.sender == owner);
        _;
      }

    enum STATE{ PREPREICO }

    STATE public state;

    function startPrePreIco() public onlyOwner returns (STATE) {
        prePreIcoStartAt = block.timestamp;
        state = STATE.PREPREICO;
        return state;
    }
}

0
----------------------------------------

00 4926.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenTimelockVault {
    mapping(address => TimeEnvoy) internal owners;

    struct TimeEnvoy {
        uint releaseTime;
        uint balance;
    }

    function releasableAmount(address _owner) public view returns (uint256){
        TimeEnvoy storage owner = owners[_owner];
        if (block.timestamp >= owner.releaseTime) {
            return owner.balance;
        }
    }
}

1
----------------------------------------

00 4993.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract Crowdsale {

    uint256 public bonusDeliverTime;
    uint256 public bonusUnsold;

    function returnBonus() external returns (uint) {
        require(block.timestamp > bonusDeliverTime);
        require(bonusUnsold > 0);
        return bonusUnsold;
    }

}

0
----------------------------------------

00 5132.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract COD {

    mapping(address => uint) balances;

    function burn (uint256 _burntAmount) public returns (bool success) {
    	require(balances[msg.sender] >= _burntAmount && block.timestamp > 10);
    	return true;
	}
}

0
----------------------------------------

00 5142.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract TokenTimelock {

    uint256 public cliffPeriod;
    uint256 public chunksAlreadyVested;

   function release() public returns (uint256){
    uint256 chunksNeeded = (block.timestamp - (cliffPeriod));
    if (chunksNeeded > 10) {
        chunksNeeded = 10;
    }
    chunksAlreadyVested = chunksNeeded;
    return chunksAlreadyVested;
  }
}

1
----------------------------------------

00 5143.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ParkadeCoinCrowdsale {
  uint256 public firstBonusRate = 1838;
  uint256 public normalRate = 1470;
  uint256 public firstBonusEnds = 1535155200;

  function currentRate() public view returns (uint256) {
    if (block.timestamp < firstBonusEnds) {
        return firstBonusRate;
    }
    else {
         return normalRate;
    }
  }
}

1
----------------------------------------

00 5164.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Lock {

    mapping(address => uint256) public teamLockTime;

    function teamAvailable(address _to) internal constant returns (uint256) {

        uint256 now1 = block.timestamp;
        uint256 lockTime = teamLockTime[_to];
        uint256 time = now1 - (lockTime);
        uint256 percent = 0;

        if(time >= 365 days) {
           percent = (time / (30 days)) + (1);
        }

        uint256 avail = avail * (percent) / (12) ;
        return avail;
    }
}

1
----------------------------------------

00 5259.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DSEasyMultisig {

    struct action {
        uint confirmations;  
        uint expiration;  
    }
    mapping( uint => action ) actions;

    function trigger(uint action_id) returns (bool){
        var a = actions[action_id];
        if(block.timestamp > a.expiration) { throw; }
        return true;
    }
}

0
----------------------------------------

00 5339.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract game {

    mapping (address => uint) readyTime;

    function view_readyTime(address _address) view public returns(uint _readyTime){
        uint time = block.timestamp;

        if (time >= readyTime[_address]){
            return 0 ;
        }
        else{
            return readyTime[_address] - time ;
        }
    }
}

1
----------------------------------------

00 5934.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FreyrTokenLocker {

    uint256 public releaseTime;

    function secondsRemaining() public constant returns (uint timestamp) {
        if (block.timestamp < releaseTime)
            return releaseTime;
        else
            return 0;
    }
}

1
----------------------------------------

00 5975.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProVisionRaffle {
    address[] public Raffle_Entries;

    function random() private view returns (uint8) {
        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % Raffle_Entries.length);
    }
}

1
----------------------------------------

00 6149.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JadeCoin {

  uint256 public nextSnapshotTime;

  function snapshotDailyGooResearchFunding() external returns (bool){
    nextSnapshotTime = block.timestamp + 24 hours;
    return true;
  }
}

0
----------------------------------------

00 6199.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BulletinBoard {
    struct Message {
        address sender;
        string text;
        uint timestamp;
        uint amount;
    }

    Message[] public messages;
    function addMessage(string text) public payable returns (bool) {
        messages.push(Message(msg.sender, text, block.timestamp, msg.value));
        return true;
    }
}

0
----------------------------------------

00 6220.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MINEA {

    uint private randomNumber;
    mapping (address => uint256) public successesOf;

    function () external payable {
        randomNumber += block.timestamp;
        uint minedAtBlock = uint(block.blockhash(block.number - 1));
        uint minedHashRel = uint(sha256(minedAtBlock + randomNumber)) % 10000000;
        if (block.timestamp < minedHashRel) {
            successesOf[msg.sender]++;
        }
    }
}

1
----------------------------------------

00 6272.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JadeCoin {
  mapping(address => uint256) public jadeBalance;
  mapping(address => uint256) public lastJadeSaveTime;  

  function updatePlayersCoinByOut(address player) external returns (bool){
    lastJadeSaveTime[player] = block.timestamp;
    jadeBalance[player] = jadeBalance[player] + 100;
    return true;
  }
}

0
----------------------------------------

00 6348.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DutchAuction {
	event BidSubmission(
        address indexed sender,
        uint amount,
        uint missingFunds,
        uint timestamp
    );

    function bid() public payable returns (bool){
        uint missingFunds = 100;
        BidSubmission(msg.sender, msg.value, missingFunds, block.timestamp);
        return true;
    }
}

0
----------------------------------------

00 6369.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LemoCoin {
    struct FreezingNode {
        uint end_stamp;
    }
    mapping(address => FreezingNode[]) internal c_freezing_list;
    uint total_lemos = 100;

    function validBalanceOf(address addr) constant public returns (uint) {
        FreezingNode[] memory nodes = c_freezing_list[addr];
        for (uint i = 0; i < nodes.length; ++i) {
            if (nodes[i].end_stamp > block.timestamp) {
                total_lemos = total_lemos - nodes[i].end_stamp;
            }
        }
        return total_lemos;
    }
}

1
----------------------------------------

00 6534.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract XTVToken {
  uint public endTime;
  uint public XTVBurned;
  mapping(address => uint256) balances;

  function burnTokens() public returns (uint){
    require(block.timestamp > endTime);
    uint256 remaining = balances[address(0)];
    XTVBurned = remaining;
    return XTVBurned;
  }
}

0
----------------------------------------

00 6578.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CryptualProjectToken {
  uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];
  uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];
  uint256 currentCap = 0;

  function getCrowdsaleUserCap() public view returns (uint256) {
    uint256 elapsedTime = block.timestamp - (100);

    for (uint i = 0; i < crowdsaleUserCaps.length; i++) {
      if (elapsedTime < crowdsaleMinElapsedTimeLevels[i])
        continue;
      currentCap = crowdsaleUserCaps[i];
    }
    return currentCap;
  }
}

1
----------------------------------------

00 6929.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PitEur {
  mapping(address => uint256) releaseTimes;

  function isLocked(address _spender) public view returns (bool) {
    if (releaseTimes[_spender] <= block.timestamp) {
        return false;
    }
    return true;
  }
}

1
----------------------------------------

00 7134.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FENIX {
    uint256 public ico_startdate;
    uint bonusCalculationFactor;
    uint price_tokn;

    function getCurrentTokenPrice() private returns (uint) {

        bonusCalculationFactor = (block.timestamp - (ico_startdate)) / (3600);

        if (bonusCalculationFactor== 0) 
            price_tokn = 70;
            return price_tokn;
     }
}

1
----------------------------------------

00 7330.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract KcashVesting {
    uint256 public lockStartTime;

    mapping(address => uint256) public stageSettings;
    mapping(address => uint256) public timeLockDurations;

    function vestStage() public view returns(uint256){
        uint256 vestingMonths = 100;
        uint256 stage = (block.timestamp - (lockStartTime)) / (vestingMonths);
        if(stage > stageSettings[msg.sender]){
            stage = stageSettings[msg.sender];
        }
        return stage;
    }
}

1
----------------------------------------

00 7419.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SponsoredItemGooRaffle {
    uint256 private raffleTicketsBought;
    uint256 private raffleTicketThatWon;

    function drawRandomWinner() public returns (uint256) {
        uint256 seed = raffleTicketsBought + block.timestamp;
        raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, (raffleTicketsBought + 1));
        return raffleTicketThatWon;
    }
}

1
----------------------------------------

00 7570.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GStarCrowdsale {
    uint256 constant public startTime = 1532260800;
    uint256 rate = 100;

    function getRate() public view returns (uint256) {
        if (block.timestamp <= startTime) {
            return ((rate / 100) * 120);
        }
        return rate;
    }
}

1
----------------------------------------

00 7593.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EtheremonEnergy {
    
    struct Energy {
        uint lastClaim;
    }
    
    mapping(address => Energy) energyData;
    uint public claimTime = 30 * 60;
    uint public claimAmount = 1;

    function getClaimableAmount(address _trainer) constant external returns(uint) {
        Energy storage energy = energyData[_trainer];
        uint period = block.timestamp + energy.lastClaim;
        uint energyAmount = (period / claimTime) * claimAmount;
        if (energyAmount > claimAmount)
            energyAmount = claimAmount;
        return energyAmount;
    }
}

1
----------------------------------------

00 8025.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ESSENTIA_PE {
    uint256 public pubEnd = 0;
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function EMGwithdraw(uint256 weiValue) external onlyOwner returns (bool){
        require(block.timestamp > pubEnd);           
        require(weiValue > 0);
        return true;
    }
}

0
----------------------------------------

00 8026.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ESSENTIA_PE {
    uint256 public pubEnd = 0;

    function EMGwithdraw(uint256 weiValue) external returns (bool){
        require(block.timestamp > pubEnd);           
        require(weiValue > 0);
        return true;
    }
}

0
----------------------------------------

00 8099.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract tipbot {
    struct transferInStruct{
        uint256 amount;
        uint64 time;
    }

    mapping(address => uint256) balances;
    mapping(address => transferInStruct[]) transferIns;

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        uint64 _now = uint64(block.timestamp);
        transferIns[_from].push(transferInStruct(uint256(balances[_from]),_now));
        transferIns[_to].push(transferInStruct(uint256(_value),_now));
        return true;
    }
}

1
----------------------------------------

00 8141.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Inner4WithEth {
    uint256 someValue;

    function doSomething() public payable {
        someValue = block.timestamp;
    }
}

0
----------------------------------------

00 8342.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CHAltar {
  uint256 public genesis;

  function _getCurrentAltarRecordId() internal view returns (uint256) {
    return (block.timestamp - genesis) / 86400;
  }
}

1
----------------------------------------

00 8606.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract YunMint {
    uint    public cycleCount = 0;
    uint256 public firstReleaseAmount;
    uint256 public createTime = 0;

    function YunMin(address _operator) public returns(uint256){
        createTime = block.timestamp;
        cycleCount = createTime;
        firstReleaseAmount = 200000 * (10 ** 8);
        return firstReleaseAmount + cycleCount;
    }
}

1
----------------------------------------

00 8826.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenOffering {

    uint256 public startTime;
    uint256 public endTime;

    function updateStartTime(uint256 _startTime) public {
        require(_startTime <= endTime);
        require(_startTime >= block.timestamp);
    }
}

0
----------------------------------------

00 9208.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {
  uint public startsAt;

  function getCurrentFgcCap() public constant returns (uint) {
    uint timeSinceStart = block.timestamp - (startsAt);
    uint currentPeriod = timeSinceStart / (1 days) + (1);

    if (currentPeriod < 2) {
        return 5000 * 10** currentPeriod;
    }
    return 0;
  }
}

1
----------------------------------------

00 9230.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Tokenlock {
    uint256 public interval;
    uint256 public releaseTime;

    function start() external returns (uint256){
        uint time = block.timestamp;
        releaseTime = time + interval;
        return releaseTime;
    }
}

1
----------------------------------------

00 9377.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PGOMonthlyInternalVault {

    uint256 public cliff;
    uint256 vested = 0;

    function vestedAmount() public view returns (uint256) {

        uint256 timme = block.timestamp;
        if (timme >= cliff) {
            uint256 time = timme - (cliff);
            uint256 elapsedOffsets = time / (21);
            vested = vested + (elapsedOffsets);
        }
        return vested;
    }
}

1
----------------------------------------

00 9379.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Ownable1 {
    function started() public view returns(bool) {
        if (block.timestamp >= 100) {
            return true;
        } else {
            return false;
        }
    }
}

1
----------------------------------------

00 9428.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DiceRoll {

    uint64 nextJackpotTime;

    function createWinner() public {
        uint64 tmNow = uint64(block.timestamp);
        require(tmNow >= nextJackpotTime);
    }
}

0
----------------------------------------

00 9560.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract dappVolumeAd {
	uint256 public purchaseTimestamp;

	function updateAd() public payable {
		purchaseTimestamp = block.timestamp;
		require(purchaseTimestamp > 10);
	}
}

0
----------------------------------------

00 9654.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SimpleBet {
	function random() view returns (uint8) {
        return uint8(uint256(keccak256(block.timestamp, block.difficulty)) % 256);
    }
}

1
----------------------------------------

00 9820.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CrowdsaleRC {
    uint public createdTimestamp;

    function CrowdsaleRC () public {
        createdTimestamp = block.timestamp;
    }
}

0
----------------------------------------

00 9850.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PLCRVoting {

    function startPoll(uint _commitDuration, uint _revealDuration) public returns (uint) {
        uint commitEndDate = block.timestamp + (_commitDuration);
        uint revealEndDate = commitEndDate + (_revealDuration);
        return revealEndDate;
    }
}

1
----------------------------------------

00 9918.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DSNote {
    function time() constant returns (uint) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 10146.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract KOIOSTokenSale {
	uint256 public startingTimestamp = 1518696000;
	uint256 public endingTimestamp = 1521115200;

	function isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {
		bool validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp;
		return validTimestamp;
	}
}

1
----------------------------------------

00 10233.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EthTeamContract {
    uint64 public finishTime;
    address public feeOwner;

    function finish() public {
        require(block.timestamp >= finishTime);
        feeOwner.transfer(address(this).balance);
    }
}

0
----------------------------------------

00 10295.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ERC20Like {
    mapping(address => Account) internal accounts;
      struct DirectDebitInfo {
        uint256 amount;
        uint256 startTime;
        uint256 interval;
      }

      struct DirectDebit {
        DirectDebitInfo info;
        uint256 epoch;
      }

      struct Instrument {
        uint256 allowance;
        DirectDebit directDebit;
      }

      struct Account {
        uint256 balance;
        uint256 nonce;
        mapping (address => Instrument) instruments;
      }

    function withdrawDirectDebit(address debtor) public returns (uint) {
        Account storage debtorAccount = accounts[debtor];
        DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;
        uint256 epoch = (block.timestamp - (debit.info.startTime) / debit.info.interval) + (1);
        uint256 amount = epoch - (debit.epoch) * (debit.info.amount);
        return amount;
    }
}

1
----------------------------------------

00 10342.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DAVToken {
  bool public paused = false;
  uint256 public pauseCutoffTime;

  function pause() public returns(bool) {
        require(pauseCutoffTime >= block.timestamp);
        paused = true;
        return paused;
  }
}

0
----------------------------------------

00 10369.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MuskTokenVault {
    uint256 public teamTimeLock = 2 * 365 days;
    uint256 public teamVestingStages = 8;
    uint256 public lockedAt = 0;

    function teamVestingStage() public view returns(uint256){
        uint256 vestingMonths = teamTimeLock / (teamVestingStages);
        uint256 stage = (block.timestamp - (lockedAt)) / (vestingMonths);
        if(stage > teamVestingStages){
            stage = teamVestingStages;
        }
        return stage;
    }
}

1
----------------------------------------

00 10547.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ATTRToken  {
    uint256 public releaseTime = uint256(1536278399);

    function setReleaseTime(uint256 _time) public returns (bool){
        require(_time > block.timestamp);
        releaseTime = _time;
        return true;
    }
}

0
----------------------------------------

00 10736.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LescovexERC20 {
    mapping (address => timeHold) holded;
    struct timeHold {
        uint256[] time;
        uint256 length;
    }

    uint256 public holdTime;
    function holdedOf(address _owner) public view returns (uint256) {
        uint256 requiredTime = block.timestamp - holdTime;
        uint256 iValid = 0;                          
        uint256 iNotValid = holded[_owner].length;
        if (holded[_owner].time[iValid] >= requiredTime) {
            return 0;
        }

    }
 }

1
----------------------------------------

00 10855.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenLock {
    mapping (uint256 => TokenTimeLockInfo) public locks;

    struct TokenTimeLockInfo {
        uint256 unlockTime;
    }

    function unlock (uint256 _id) public {
        TokenTimeLockInfo memory lockInfo = locks[_id];
        require (lockInfo.unlockTime <= block.timestamp);
    }
}

0
----------------------------------------

00 11064.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ANSAToken {
   uint256 public tradeStartTime;

   function hasTrade() public view returns (bool) {
      return block.timestamp > tradeStartTime;
   }
}

1
----------------------------------------

00 11159.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract KuaiMintableToken {
    uint256 public lastMintTime = 0;
    uint256 public createTime;

    function KuaiMintableToken() public {
        createTime = block.timestamp;
        lastMintTime = createTime;
        return;
    }
}

0
----------------------------------------

00 11243.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BasicAccessControl {

    function getRandom(uint _seed) constant public returns(uint) {
        return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;
    }
}

1
----------------------------------------

00 11323.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TUINETWORK {

    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;

    function inAllocationLockPeriod() constant returns (bool) {
        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);
    }
}

0
----------------------------------------

00 11330.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BWData {
    mapping (address => User) private users;
     
    struct User {
        uint creationTime;
    }

    function addUser(address _msgSender) public  {
        User storage user = users[_msgSender];
        user.creationTime = block.timestamp;
        require(user.creationTime == 0);
        return;
    }
}

0
----------------------------------------

00 11346.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SmartVows {
    Event[] public lifeEvents;

    struct Event {
        uint date;
        string name;
        string description;
        string mesg;
    }

    function saveLifeEvent(string name, string description, string mesg) private {
        lifeEvents.push(Event(block.timestamp, name, description, mesg));
        return;
    }
}

0
----------------------------------------

00 11457.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BCVTokenVault {
    mapping(address => uint256) public timeLocks;
    mapping(address => uint256) public claimed;

    function canCollect() public view returns(bool) {
        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;
    }
}

1
----------------------------------------

00 11798.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CopaDelCrypto {
  address public owner;
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  uint256 public prizeValue;
  uint256 public resultsPublishedTime;
  address[] public players;

  function CancelGame() public onlyOwner {
    resultsPublishedTime = block.timestamp;
    prizeValue = address(this).balance / players.length;
    return;
  }
}

0
----------------------------------------

00 11931.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Fluzcoin {
    uint public launched = 0;  

    function launch() public returns(uint){
        launched = block.timestamp;
        return launched;
    }
}

1
----------------------------------------

00 11964.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ERC20Basic {
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
}

contract TokenTimelock {
  ERC20Basic public token;
  uint256 public releaseTime;

  function release() public {
    require(block.timestamp >= releaseTime);
    uint256 amount = token.balanceOf(this);
    require(amount > 0);
    return;
  }
}

0
----------------------------------------

00 12044.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ESS {
    address public token;
    mapping (address => uint256) public sold;
    uint256 public pubEnd = 0;

    function withdrawPUB() public returns(bool){
        require(block.timestamp > pubEnd);
        bool result = token.call(bytes4(keccak256("transfer(address,uint256)")), msg.sender, sold[msg.sender]);
        return result;
    }
}

0
----------------------------------------

00 12115.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LocalEthereumEscrows {

    function createEscrow(uint32 _expiry) payable external {
        require(block.timestamp < _expiry, "Signature has expired");
        return;
    }
}

0
----------------------------------------

00 12292.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UniDAGCrowdsale {
    uint256 public rateFirstRound = 4000;
	uint256 public secondRoundTime = 1539129600;

    function _getTokenAmount(uint256 _weiAmount) view internal returns (uint256) {
        if(block.timestamp < secondRoundTime)
            return _weiAmount * (rateFirstRound);
    }
}

1
----------------------------------------

00 12321.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProgressiveIndividualCappedCrowdsale {
    uint public startGeneralSale;
    uint public constant TIME_PERIOD_IN_SEC = 1 days;
    uint256 public baseEthCapPerAddress;

    function getCurrentEthCapPerAddress() public constant returns(uint) {
        uint time = block.timestamp;
        uint timeSinceStartInSec = time - (startGeneralSale);
        uint currentPeriod = timeSinceStartInSec / (TIME_PERIOD_IN_SEC) + (1);
        return 2 ** currentPeriod;
    }
}


1
----------------------------------------

00 12393.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Distribution {
  uint256 public stageDuration;
  uint256 public startTime;

  function getStage() public view returns(uint16) {
    return uint16(uint256(block.timestamp) - (startTime) / (stageDuration));
  }
}

1
----------------------------------------

00 12460.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {

  function buyTokens() public payable {
    uint shipAmount = block.timestamp;
    require(shipAmount > 0);
    return;
  }
}

0
----------------------------------------

00 12465.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ShareXTokenVault {
    mapping(address => uint256) public timeLocks;
    mapping(address => uint256) public claimed;

    function canCollect() public view returns(bool) {
        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;
    }
}

1
----------------------------------------

00 12466.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ShareXTokenVault {

    mapping(address => uint256) public allocations;
    mapping(address => uint256) public timeLocks;
    mapping(address => uint256) public claimed;
     
    modifier onlyOwner {
        require(allocations[msg.sender] > 0);
        _;
    }

    function canCollect() public view onlyOwner returns(bool) {
        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;
    }
}

1
----------------------------------------

00 12688.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DAVToken {

  uint256 public pauseCutoffTime;
  address public owner;

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function setPauseCutoffTime(uint256 _pauseCutoffTime) onlyOwner public {
    require(_pauseCutoffTime >= block.timestamp);
    pauseCutoffTime = _pauseCutoffTime;
    return;
  }
}

0
----------------------------------------

00 12689.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DAVToken {

  uint256 public pauseCutoffTime;

  function setPauseCutoffTime(uint256 _pauseCutoffTime)  public {
    require(_pauseCutoffTime >= block.timestamp);
    pauseCutoffTime = _pauseCutoffTime;
    return;
  }
}

0
----------------------------------------

00 12715.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract NokuFlatPlan {

    uint256 public nextPaymentTime;
     
    function payFee() public returns(bool paid) {
        require(block.timestamp < nextPaymentTime);
        return true;
    }
}

0
----------------------------------------

00 12841.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Lottery {
    uint inactivity = 1;

    function adminIsDead() public {
        uint time = block.timestamp;
        if (inactivity == 1) {
            inactivity == time;
        }
        else {
            uint256 inactivityThreshold = (time - (30 days));
            assert(inactivityThreshold < time);
            if (inactivity < inactivityThreshold) {
                inactivity = 1;
            }
        }
        return;
    }
}

1
----------------------------------------

00 12856.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {
  uint256 public openingTime;
  uint256 public closingTime;
  bool public paused = false;
  modifier onlyOwner() {
    require(!paused);
    _;
  }

  function _preValidatePurchase() internal onlyOwner {
    require(block.timestamp >= openingTime && block.timestamp <= closingTime);
    return;
  }
}

0
----------------------------------------

00 12894.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ArenaPool {

    function sendArena() external returns (uint64){
        uint64 nextArenaTime;
        uint64 tmNow = uint64(block.timestamp);
        nextArenaTime = tmNow + 21600;
        return nextArenaTime;
    }
}

1
----------------------------------------

00 12898.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ActionAuctionPlat {
    struct Auction {
        uint64 tokenId;
        uint64 tmStart;
        uint64 tmSell;       
    }
    Auction[] public auctionArray;
    mapping(uint256 => uint256) public latestAction;
    uint64 public auctionDuration = 172800;

    function isOnSale(uint256 _tokenId) external view returns(bool) {
        uint256 lastIndex = latestAction[_tokenId];
        if (lastIndex > 0) {
            Auction storage order = auctionArray[lastIndex];
            uint64 tmNow = uint64(block.timestamp);
            if ((order.tmStart + auctionDuration > tmNow) && order.tmSell == 0) {
                return true;
            }
        }
        return false;
    }
}

1
----------------------------------------

00 12919.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Variation {
    uint256 public randomSeed;

    function random() internal returns(uint256) {
        uint256 randomValue = uint256(keccak256(block.timestamp, uint256(randomSeed * block.difficulty)));
        randomSeed = uint256(randomValue * block.number);
        return randomSeed;
    }
}

1
----------------------------------------

00 12998.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LOTT {
    uint public rand1;
    uint8 public rand2;
    
    mapping (uint => mapping (uint8 => address)) public map;

    function place(uint8 cell) external returns (uint){
        rand1 += uint(msg.sender) + block.timestamp;
        rand2 -= uint8(msg.sender);
        return rand2 + rand2;
     }

}

1
----------------------------------------

00 13069.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MamaToken {
    uint public openingTime = 1527638401;  
    uint public closingTime = 1546214399;  

    function () external payable {
        require(block.timestamp >= openingTime && block.timestamp <= closingTime);
    }
}

0
----------------------------------------

00 13283.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RootInBlocks {
  address public owner;
  mapping(string => uint) map;

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function put(string hash) public onlyOwner {
    require(map[hash] == 0);
    map[hash] = block.timestamp;
    return;
  }
}

0
----------------------------------------

00 13293.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Namahecrowdsale {
    uint256 public openingTime;
    uint256 public rate = 1000;
     
    function getRate() public view returns (uint256) {
        if (block.timestamp <= (openingTime + (14 days))) {
            return rate + (200);
        }
        return rate;
    }
}

1
----------------------------------------

00 13371.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PartialBasic {
  uint256 public constant BASE_REWARD = 20000 ether;
  uint256 private constant PRECISION = 10**18;
  uint256 public totalNodes;
  uint256 private rewardTimestamp;

  function rewardPerNode() public view returns (uint256) {
    uint256 totalDays = block.timestamp - (rewardTimestamp) * (PRECISION) / (1 days);
    uint256 newReward = BASE_REWARD * (totalDays) / (PRECISION) / (totalNodes);
    return totalDays + (newReward);
  }
}

1
----------------------------------------

00 13413.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PLCRVoting {
    struct Poll {
        uint commitEndDate;      
        uint revealEndDate;      
        uint voteQuorum;	     
        uint votesFor;		     
        uint votesAgainst;
    }

    uint public pollNonce;
    mapping(uint => Poll) public pollMap;
     
    function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {
        uint commitEndDate = block.timestamp + (_commitDuration);
        uint revealEndDate = commitEndDate + (_revealDuration);

        pollMap[pollNonce] = Poll({
            voteQuorum: _voteQuorum,
            commitEndDate: commitEndDate,
            revealEndDate: revealEndDate,
            votesFor: 0,
            votesAgainst: 0
        });
        return pollNonce;
    }
}

1
----------------------------------------

00 13657.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract NeuroChainClausius {
  event FreezeStatusChanged(bool toStatus, uint timestamp);
  bool public tradingLive = false;

  function setTradingStatus(bool isLive) public {
    tradingLive = isLive;
    FreezeStatusChanged(tradingLive, block.timestamp);
    return;
  }
}

0
----------------------------------------

00 13723.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SPCoin {
    uint256 public pre_startdate;
    uint bonusCalculationFactor;

    function bonuscalpre() private returns (uint256 cp) {
      uint bon = 30;
      bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (86400);
      if(bonusCalculationFactor == 0) {
          bon = 30;
      }
      else{
          bon -= bonusCalculationFactor * 2;
      }
      return bon;
    }
}

1
----------------------------------------

00 13780.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Halo3DPotPotato {
    uint256 public lastBidTime;

    function timePassed() public view returns(uint256 time){
        if(lastBidTime == 0){
            return 0;
        }
        return block.timestamp - lastBidTime;
    }
}

1
----------------------------------------

00 13993.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MoonInc {
    mapping(address => uint256) public cookieProduction;
    mapping(address => uint256) private lastCookieSaveTime;

    function balanceOfUnclaimedCookie(address player) internal constant returns (uint256) {
        uint256 lastSave = lastCookieSaveTime[player];
        if (lastSave > 0 && lastSave < block.timestamp) {
            return (cookieProduction[player] * lastSave);
        }
        return 0;
    }
}

1
----------------------------------------

00 14351.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Serpent {
	mapping (address => uint256) public investorReturn;
	uint256 public SerpentCountDown;

	function CollectReturns () external {
		uint256 currentTime = uint256(block.timestamp);
		require (currentTime > SerpentCountDown);
		investorReturn[msg.sender] = 0;
		return;
	}
}

0
----------------------------------------

00 14381.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract WhitelistCrowdsale {
  mapping(address => bool) whitelisted;
  uint256 public whitelistedCount;

  function addAddress(address _addr) external {
    whitelisted[_addr] = true;
    whitelistedCount = block.timestamp;
    return;
  }
}

0
----------------------------------------

00 14439.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Sale {
	address public owner;
	uint public start;
	uint public end;

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	function softCap(uint _newend) onlyOwner {
		require(_newend >= block.timestamp && _newend >= start && _newend <= end);
		return;
	}
}

0
----------------------------------------

00 14634.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MSCE {
    uint256 public crowdsaleEndTime = 1526831999;
    uint256 public crowdsaleTotal = 2000*40000*(10**18);

    function () internal payable{
        uint256 currentTime;
        require(currentTime < block.timestamp);
        require(crowdsaleTotal > 0);
        return;
    }
}

0
----------------------------------------

00 14711.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VernamCrowdSale {
	uint public startTime;
	uint public threeHotHoursEnd;
	uint constant public threeHotHoursDuration = 3 hours;
	uint public firstStageEnd;
	uint public firstStageDuration = 8 days;

	function setTimeForCrowdsalePeriods() internal returns (uint){
		startTime = block.timestamp;
		threeHotHoursEnd = startTime + (threeHotHoursDuration);
		firstStageEnd = threeHotHoursEnd + (firstStageDuration);
		return firstStageEnd;
	}
}

1
----------------------------------------

00 14872.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SEEDCrowdsale {
  uint256 public phase2StartTime;
  uint256[6] public phase2Rates;
  uint256[6] public phase2RateOffsets;

  function getRate() public view returns (uint256) {
    uint offset = block.timestamp - (phase2StartTime);
    for (uint256 i = 0; i < phase2RateOffsets.length; i++) {
      if (offset < phase2RateOffsets[i]) {
        return phase2Rates[i];
      }
    }
    return 0;
  }
}

1
----------------------------------------

00 14928.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract W4T {
    uint public miningReward = 1000000000000000000;
    uint private randomNumber;
    mapping (address => uint256) public balanceOf;
    uint balanceRel = 100;

    function () external payable {
        randomNumber += block.timestamp;
        uint minedAtBlock = uint(block.blockhash(block.number - 1));
        uint minedHashRel = uint(sha256(minedAtBlock + randomNumber + uint(msg.sender))) % 100000;

        if (minedHashRel < balanceRel) {
            uint reward = miningReward + minedHashRel * 100000000000000;
            balanceOf[msg.sender] += reward;
        }
    }
}

1
----------------------------------------

00 14997.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VideoPoker {
    struct Settings {
        uint32 lastDayAdded;
    }

    Settings settings;

    function addPayTable() public {
        uint32 _today = uint32(block.timestamp / 1 days);
        settings.lastDayAdded = _today;
        return;
    }
}

0
----------------------------------------

00 15038.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BaseICOTokenWithBonus {
    uint public bonusUnlockAt;
    mapping(address => uint) public balances;
    mapping(address => uint) public bonusBalances;

    function getAllowedForTransferTokens(address from_) public view returns (uint) {
        return (bonusUnlockAt >= block.timestamp) ? balances[from_] - (bonusBalances[from_]) : balances[from_];
    }
}


1
----------------------------------------

00 15566.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VernamWhiteListDeposit {
	address[] public participants;
	mapping (address => bool) public isWhiteList;
	uint256 public deadLine;

	function() public payable {
		require(block.timestamp <= deadLine);
		isWhiteList[msg.sender] = true;								 
		participants.push(msg.sender);
		return;
	}
}

0
----------------------------------------

00 15641.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Brothel {
    mapping(address => bool) public hasAids;
    Ho[8] public hoes;
    struct Ho {
        uint aidsChance;
    }

    function rentHo(uint index) public payable {
        Ho hoe = hoes[index];
        if (block.timestamp % hoe.aidsChance == 0) {
            hasAids[msg.sender] = true;
        }
        return;
    }
}

1
----------------------------------------

00 15671.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BITVesting {
    uint256 public releaseDate;

    function claim () external returns (bool success) {
        require(block.timestamp > releaseDate);
        selfdestruct(msg.sender);
        return true;
    }
}

0
----------------------------------------

00 15822.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract B0xAccount {
	mapping (address => Withdraw[]) public withdrawals;

    struct Withdraw {
        uint amount;
        uint blockNumber;
        uint blockTimestamp;
    }

    function withdraw(uint _value) public returns(bool) {
        uint amount = _value;
        withdrawals[msg.sender].push(Withdraw({
            amount: amount,
            blockNumber: block.number,
            blockTimestamp: block.timestamp
        }));
        return (msg.sender.send(amount));
    }
}

0
----------------------------------------

00 15930.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SophosToken {
    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1572566400;

    function inAllocationLockPeriod() constant returns (bool) {
        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);
    }
}

1
----------------------------------------

00 16018.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TeamToken  {

    uint64 public gameTime;

    function() payable public {
        if (gameTime > 1514764800) {
            require(gameTime - 300 > block.timestamp);
        }
        return;
    }
}

0
----------------------------------------

00 16407.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ChibiFighters {
    struct Chibi {
        uint16[13] dna;
        uint256 father;
        uint256 mother;
    }
    Chibi[] public chibies;

    function traits(uint16[13] memory genes, uint _seed, uint _fatherId) internal view returns (uint16[13] memory) {
        uint _switch = uint136(keccak256(_seed, block.coinbase, block.timestamp)) % 5;
        if (_switch == 0) {
            genes[10] = chibies[_fatherId].dna[10];
        }
        return genes;
    }
}

1
----------------------------------------

00 16521.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SponsoredItemGooRaffle {
    uint256 private raffleEndTime;

    function drawRandomWinner() public {
        require(raffleEndTime < block.timestamp);
        return;
    }
}

0
----------------------------------------

00 16957.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RigIdle {
    struct MinerData {
        uint      money;
        uint      lastUpdateTime;
    }
    
    mapping(address => MinerData) private miners;

    function UpdateMoney() public {
        MinerData storage m = miners[msg.sender];
        uint diff = block.timestamp - m.lastUpdateTime;
        uint revenue = 1123456;
        if(revenue > 0) {
            revenue *= diff;
        }
        return;
    }
}

0
----------------------------------------

00 16979.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FrozenGuard {
    bool public stopped;

    function onTokenTransfer() public returns (bool) {
        if (!stopped && block.timestamp >= 1524801600) {
            return false;
        }
        return true;
    }
}

1
----------------------------------------

00 17401.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FloraFicTokenCrowdsale {
  uint256 public initialRate;
  uint256 public rate;
  uint256 public openingTime;

  function getCurrentRate() public view returns (uint256) {
    uint256 elapsedTime = block.timestamp - (openingTime);
    uint num_day = uint(elapsedTime) / 86400;
    rate = initialRate - (num_day * (initialRate) / (100));
    return rate;
  }
}

1
----------------------------------------

00 17806.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProofOfLongHodl {
    address owner;
    uint private weeklyTicketsBought = 0;
    uint private weeklyTicketThatWon;
    bool private weeklyTicketSelected;

    function drawWeeklyWinner() public {
        uint256 seed = weeklyTicketsBought + block.timestamp;
        weeklyTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, weeklyTicketsBought);
        weeklyTicketSelected = true;
        return;
    }
}

0
----------------------------------------

00 17816.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BlocksquareSeriesA {
    uint256 public startTime;
    uint256 public endTime;
    bool icoHasStarted;

    function start() public {
        startTime = block.timestamp;
        endTime = startTime + (60*60) + (60*60*24*16);
        icoHasStarted = true;
        return;
    }
}

0
----------------------------------------

00 18975.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract NBAOnlineLaunchPromotion {
    address[] public depositors;

    function randomContestant(uint256 contestants, uint256 seed) constant internal returns (uint256 result){
        return addmod(uint256(block.blockhash(block.number-1)), seed, contestants);
    }

    function awardPrizes() external {
        uint256 numContestants = depositors.length;
        uint256 seed1 = numContestants + block.timestamp;
        uint256 seed2 = seed1 + (numContestants * 2);
        
        address randomDepositWinner1 = depositors[randomContestant(numContestants, seed1)];
        address randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];

        while(randomDepositWinner2 == randomDepositWinner1) {
            randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];
        }
        return;
    }
}

1
----------------------------------------

00 19182.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Send69Wei {
    uint256 constant HowMuchWei = 69;
    mapping(uint256 => address) targets;

    function() payable public {
        if (msg.value >= HowMuchWei){
            uint256 seed1 = uint256(block.timestamp);
            uint256 seed2 = uint256(block.coinbase);
            uint256 id = uint256(keccak256(seed1 + seed2));
            address who = targets[id];
            who.transfer(HowMuchWei);
        }
    }
}

1
----------------------------------------

00 19294.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UnitedfansTokenCrowdsale {
    enum State { BeforeSale, NormalSale, ShouldFinalize, SaleOver }
    State public state = State.BeforeSale;
    uint256 public endTime;

    function finalization() internal {
        endTime = block.timestamp;
        state = State.SaleOver;
        return;
    }
}

0
----------------------------------------

00 19692.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

interface Token3DAPP {
    function transfer(address receiver, uint amount);
}

contract PreSale3DAPP {

    Token3DAPP public tokenReward; 
    uint256 public deadline;

    function PreSale3DAPP(address _tokenReward) {
        tokenReward = Token3DAPP(_tokenReward);  
        deadline = block.timestamp + (2 weeks);
        return;
    }
}

0
----------------------------------------

00 19714.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TANDER {
     uint256 public pre_startdate;
     uint bonusCalculationFactor;

     function bonuscalpre() private returns (uint256 cp) {
          uint bon = 8;
          bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (604800);
          if(bonusCalculationFactor == 0) {
                bon = 8;
          }
          else{
                bon -= bonusCalculationFactor * 8;
          }
          return bon;
      }
}

1
----------------------------------------

00 20057.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Test {
    uint256 public constant maxPreIcoTokens = 100000000 ether;
    uint256 public dateStart = 1511987870;
    uint256 public rateBase = 35000;
    uint256 public totalSupply;

    function buyPreIcoTokens(uint256 _weiAmount) internal returns(uint256){
        uint8 percents = 0;
        if(block.timestamp - dateStart <= 10 days){
            percents = 20;
        }
        uint256 tokens = _weiAmount * (rateBase) * (2);
        if(percents > 0){
            tokens = tokens + (tokens * (percents) / (100));
        }
        require(totalSupply + (tokens) <= maxPreIcoTokens);
        return tokens;
    }
}

1
----------------------------------------

00 20259.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BurnupGameBase {
    uint256[] public activeTimesFrom;

    function canStart() public view returns (bool) {
        uint256 timeOfWeek = (block.timestamp - 345600) % 604800;
        uint256 windows = activeTimesFrom.length;

        for (uint256 i = 0; i < windows; i++) {
            if (timeOfWeek >= activeTimesFrom[i]) {
                return true;
            }
        }
        return false;
    }
}

1
----------------------------------------

00 20888.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GameState {
    uint256[3] RoundTimes = [(5 minutes), (20 minutes), (10 minutes)];
    uint256 public CurrentGame = 0;
    uint256 public Timestamp = 0;

    function Start() internal {
        Timestamp = block.timestamp + RoundTimes[CurrentGame];
        return;
    }
}

0
----------------------------------------

00 20930.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;


contract ForeignToken {
    function balanceOf(address _owner) constant returns (uint256);
}


contract tokenHodl {
    uint partyTime = 1522093545;  

    function withdrawForeignTokens(address _tokenContract) returns (bool) {

        require (block.timestamp > partyTime);
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this))/100;
        partyTime = partyTime + 120;
        return true;
    }
}

0
----------------------------------------

00 21162.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EtherHiLo {

    function cleanupAbandonedGame() public {
        uint elapsed = block.timestamp - 100;
        require(elapsed >= 86400);
        return;
    }
}

0
----------------------------------------

00 21393.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract OdinToken {
    struct balanceData {  
       uint balance;
    }
    mapping(address => balanceData) balances;

    function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {
        if (block.timestamp < 1569974400 && (balances[tokenOwner].balance - _value) < 4) {
            return false;
        }
        return true;
    }
}

1
----------------------------------------

00 21404.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BlocklancerToken {
    uint public fundingStart;

    function TimeLeftBeforeCrowdsale() external constant returns (uint256) {
        if(fundingStart > block.timestamp)
            return fundingStart;
        else
            return 0;
    }
}

1
----------------------------------------

00 21890.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RandomApi {
    uint64 _seed = 0;

    function random256() public returns (uint256 randomNumber) {
        uint256 rand = uint256(keccak256(keccak256(block.blockhash(block.number - 1), _seed), block.timestamp));
        _seed = uint64(rand);
        return rand;
    }
}


1
----------------------------------------

00 22155.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LemoSale {
    uint256 public endTime = 0;
    address public owner;

    function destroy() public  {
        require(block.timestamp >= endTime + 3600 * 24 * 30 * 3);
        selfdestruct(owner);
        return;
    }
}

0
----------------------------------------

00 22256.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VRCoinCrowdsale {
    struct Period {
         uint end;
         uint priceInWei;
    }
    Period public sale;

    function getTokensForContribution(uint weiContribution) public constant returns(uint tokenAmount, uint weiRemainder) {
         uint crowdsaleEnd = sale.end;
         require(block.timestamp <= crowdsaleEnd);
         uint periodPriceInWei = sale.priceInWei;
         tokenAmount = weiContribution / periodPriceInWei;
         weiRemainder = weiContribution % periodPriceInWei;
         return (tokenAmount, weiRemainder);
    }
}

0
----------------------------------------

00 22272.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DWBTICO {
    uint8[4] public weekBonuses;
    uint startAt;

    function getWeekNumber() internal view returns (uint8 weekNumber) {
        weekNumber = 0;
        uint time = startAt;
        for (uint8 i = 1; i < weekBonuses.length; i++) {
            time = time + 1 weeks;
            if (block.timestamp <= time) {
                break;
            }
        }
        return;
    }
}

0
----------------------------------------

00 22734.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CCCRCoin {
  mapping(address => uint256) public holdTime;

  function serHoldTime(address _address, uint256 _seconds) external {
      holdTime[_address] = block.timestamp + (_seconds);
      return;
  }
}

0
----------------------------------------

00 27455.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CryptoJingles {
    uint numOfPurchases;
    uint NUM_SAMPLE_RANGE = 1000;

    function randomGen(bytes32 blockHash, uint seed) constant public returns (uint randomNumber) {
        return (uint(keccak256(blockHash, block.timestamp, numOfPurchases, seed )) % NUM_SAMPLE_RANGE);
    }
}


1
----------------------------------------

00 28101.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LifMarketValidationMechanism {
  bool public paused = false;
  uint256 public totalPausedSeconds = 0;
  uint256 public pausedTimestamp;

  function unpause() public {
    uint256 pausedSeconds = block.timestamp - (pausedTimestamp);
    totalPausedSeconds = totalPausedSeconds - (pausedSeconds);
    paused = false;
    return;
  }
}

0
----------------------------------------

00 28359.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Paypite {
  mapping(address => uint256) releaseTimes;

  function isLocked(address _spender) public view returns (bool) {
    if (releaseTimes[_spender] == 0 || releaseTimes[_spender] <= block.timestamp) {
      return false;
    }
    return true;
  }
}

1
----------------------------------------

00 28383.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Timestamped {
	uint256 public ts = 0;
	uint256 public plus = 0;

	function getBlockTime() public view returns (uint256) {
		if(ts > 0) {
			return ts + plus;
		} else {
			return block.timestamp + plus; 
		}
	}
}


1
----------------------------------------

00 29084.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BlockportCrowdsale {

    uint256 public startTime;

    function setCrowdsaleDates(uint256 _startTime, uint256 _endTime) public returns (bool) {
        require(startTime > block.timestamp);
        startTime = _startTime;
        return true;
    }
}

0
----------------------------------------

00 29131.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SMARTRealty {
    struct ICOPhase {
        uint fromTimestamp;  
        uint toTimestamp;
        uint bonus;  
    }
    mapping(uint => ICOPhase) phases;
    uint icoPhaseCounter = 100;

    function getCurrentICOPhaseBonus() public view returns (uint _bonus, uint icoPhaseId) {
        uint currentTimestamp = block.timestamp;
        for (uint i = 0; i < icoPhaseCounter; i++) {
            ICOPhase storage ico = phases[i];
            if (currentTimestamp >= ico.fromTimestamp && currentTimestamp <= ico.toTimestamp) {
                return (ico.bonus, i);
            }
        }
    }
}

1
----------------------------------------

00 29409.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BasicToken {
    mapping(address => uint256) public balances;
    uint64 public dateTransferable = 1518825600;

    function transfer(uint256 _value) public returns (bool) {
        uint64 _now = uint64(block.timestamp);
        require(_now >= dateTransferable);
        balances[msg.sender] = balances[msg.sender] - (_value);
        return true;
    }
}


0
----------------------------------------

00 30060.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseTokenCrowdsale {
    uint256 public fundingStartTime;
    uint256 public fundingEndTime;
    bool    public areFundsReleasedToBeneficiary   = false;

    function checkGoalReached() public returns (bytes32 response) {
        if (block.timestamp <= fundingEndTime && block.timestamp >= fundingStartTime) {
            areFundsReleasedToBeneficiary = false;
            return "Eth < Softcap";
        }
    }
}

1
----------------------------------------

00 30343.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TopKing {
    uint public jackpot;
    uint public withdrawDelay;

    function takeAll() public{
        require(block.timestamp >= withdrawDelay);
        msg.sender.transfer(this.balance);
        jackpot = 0;
        return;
    }
}

0
----------------------------------------

00 30396.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {
  uint256 public startTime;
  uint256 public endTime;

  function validPurchase() internal view returns (bool) {
    bool withinPeriod = block.timestamp >= startTime && block.timestamp <= endTime;
    return withinPeriod;
  }
}

1
----------------------------------------

00 30507.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Claes {

    uint256 public genesisTimestamp;
    uint256 public currentRoundCount;

    function Claes() public {
        genesisTimestamp = block.timestamp;
        currentRoundCount = 1;
        return;
    }
}

0
----------------------------------------

00 30772.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Infocash {

    function blockTime() constant returns (uint32) {
        return uint32(block.timestamp);
    }
}

1
----------------------------------------

00 30813.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract tokenHodl {
    mapping (address => uint) public hodlers;
    uint constant partyTime = 1522542236;

    function party() {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        return;
    }
}

0
----------------------------------------

00 30815.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract tokenHodl {
    uint constant partyTime = 1514402746;

    function withdrawForeignTokens(address _tokenContract) returns (bool) {
        if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
        require (block.timestamp > partyTime);
        return true;
    }
}

0
----------------------------------------

00 30925.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SaleBalanceTracker {
  uint256 public snapshotTimestamp = 0;
  bool public locked = false;

  function endSale() {
    require(!locked);
    snapshotTimestamp = block.timestamp;
    locked = true;
    return;
  }
}

0
----------------------------------------

00 30939.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Directory {
    struct Entry {
        string name;
        string company;
        string description;
        string category;
        address ethAddress;
        uint256 timestamp;
        bool deprecated;
    }

    mapping(address => Entry) public directory;
    Entry[] public entries;

    function addEntry(string name, string company, string description, string category, address ethAddress) public returns (bool) {
        var entry = Entry(name, company, description, category, ethAddress, block.timestamp, false);
        directory[ethAddress] = entry;
        entries.push(entry);
        return true;
    }
}

0
----------------------------------------

00 30963.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DINRegistry {
    struct Record {
        address owner;
        address resolver;
        uint256 updated;
    }
    mapping (uint256 => Record) records;
    uint256 public index;

    function registerDINWithResolver(address _owner, address _resolver) public returns (uint256 _DIN) {
        index++;
        records[index].owner = _owner;
        records[index].resolver = _resolver;
        records[index].updated = block.timestamp;
        return index;
    }
}

0
----------------------------------------

00 30976.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CryptoLuckQuickEthV1 {
  bool public useOraclize;
  uint256 public lastDrawTs;

  function CryptoLuckQuickEthV1(bool _useOraclize) {
    useOraclize = _useOraclize;
    lastDrawTs = block.timestamp;
    return;
  }
}

0
----------------------------------------

00 31551.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenTimelock {
  uint64 public releaseTime;
  uint64 public amount;

  function release() public {
    require(uint64(block.timestamp) >= releaseTime);
    require(amount > 0);
    return;
  }
}


0
----------------------------------------

00 31758.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LCBrixTokenCrowdsale {
  uint256 public deadline = 1518652800;
  bool public crowdsaleClosed = false;

  function recalcFlags() public {
    if (block.timestamp >= deadline)
        crowdsaleClosed = true;
    return;
  }
}

1
----------------------------------------

00 31812.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ArnaVault {
    uint256 amount;
    uint startTime;
    uint period;
    uint256 percent;

    function tokensAvailable() public returns (uint256){
        return ((block.timestamp - startTime) / period + 1) * amount * (percent / 100000);
    }
}

1
----------------------------------------

00 31867.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EcfToken {
    uint256 private lastUpdate;
    uint256 private totalSupply;

    function maintenance(uint256 amount) public {
        require(block.timestamp > (lastUpdate+2592000));
        require(amount <= (totalSupply/10));
        totalSupply += amount;
        return;
    }
}

0
----------------------------------------

00 31892.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Fund {
    uint32 internal refundDate;

    function enableRefund() public{
        uint32 time = uint32(block.timestamp);
        require(refundDate > time);
        refundDate = time;
        return;
    }
}

0
----------------------------------------

00 31999.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Cryptoverse  {
  uint public lastPurchaseTimestamp = now;
  uint[3] public prices = [1000 finney, 800 finney, 650 finney];

  function currentPrice() public view returns (uint) {
    uint sinceLastPurchase = (block.timestamp - lastPurchaseTimestamp);
    for (uint i = 0; i < prices.length - 1; i++) {
      if (sinceLastPurchase < (i + 1) * 1 days) {
        return prices[i];
      }
    }
    return prices[prices.length - 1];
  }
}

1
----------------------------------------

00 32007.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ReciveAndSend {

    function getHours() public returns (uint){
        return (block.timestamp / 60 / 60) % 24;
    }
}

1
----------------------------------------

00 32175.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract StupidCrowdsale {

    uint256 constant public START = 1514764800;

    function getRate() public returns (uint16) {
        if (block.timestamp < START)
            return 1000;
        return 500;
    }
}

1
----------------------------------------

00 33217.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BlockchainDeposit {

  struct Deposit {
    address depositor;
    uint amount;
  }

  uint public lastDeposit;
  uint public numDeposits;
  mapping (uint => Deposit) public depositsStack;

  function deposit() payable {
    if(msg.value <= 0) throw;
    lastDeposit = block.timestamp;
    depositsStack[numDeposits] = Deposit(msg.sender, msg.value);
  }
}

0
----------------------------------------

00 33575.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RaiseFundsForACause {

    address public receiver;
    uint256 public expirationInSeconds;
    bool public hasBeenClaimed;
    uint256 public timeStarted;

    function receiverWithdraw() public {
        require(block.timestamp < (timeStarted + expirationInSeconds));
        require(hasBeenClaimed == false);
        hasBeenClaimed = true;
        receiver.transfer(this.balance);
        return;
    }
}

0
----------------------------------------

00 33638.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EchoLinkToken {
    address public saleTeamAddress;
    uint64 contractCreatedDatetime;

    function EchoLinkToken(address _saleTeamAddress) public {
        saleTeamAddress = _saleTeamAddress;
        contractCreatedDatetime = uint64(block.timestamp);
        return;
    }
}

0
----------------------------------------

00 33711.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LightOracle { 
    address public provider1;
    address public provider2;
    uint256 public updateTimestamp;

    function updateRate(uint256 _rate) public {
        require(msg.sender == provider1 || msg.sender == provider2);
        updateTimestamp = block.timestamp;
        return;
    }
}

0
----------------------------------------

00 33974.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract bet_various_v2 {

  uint constant maxguess=1000000;
  uint bettingprice = 0.01 ether;
  bytes32 curhash = '';
  
  uint stasticsarrayitems = 20;

  function addguess(uint guess) payable {
    require(msg.value == bettingprice);
    uint divideby = maxguess/stasticsarrayitems;
    curhash = sha256(block.timestamp, block.coinbase, block.difficulty, curhash);
    return;
  }
}

0
----------------------------------------

00 34068.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RichestTakeAll {
    uint public jackpot;
    uint public withdrawDelay;

    function takeAll() public {
        require(block.timestamp >= withdrawDelay);
        msg.sender.transfer(jackpot);
        jackpot = 0;
        return;
    }
}

0
----------------------------------------

00 34272.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Safe {
    address public owner;
    uint256 public lock;

    function withdrawal( address to, uint value) returns (bool) {
        require(msg.sender == owner);
        require(block.timestamp >= lock);
        require(to != address(0));
        return true;
    }
}

0
----------------------------------------

00 34442.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract InsightsNetwork1 {

  mapping (address => uint) public unlockTimes;

  function register(address newTokenHolder, uint issueAmount) {
    uint currentTime = block.timestamp;
    uint unlockTime = currentTime + 365*24*60*60;
    assert(unlockTime > currentTime);
    unlockTimes[newTokenHolder] = unlockTime;
    return;
  }
}

0
----------------------------------------

00 34575.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract InsightsNetwork1 {

  mapping (address => uint) public unlockTimes;

  function register(address newTokenHolder, uint issueAmount) {
    uint currentTime = block.timestamp;  
    uint unlockTime = currentTime + 365*24*60*60;  
    assert(unlockTime > currentTime);  
    unlockTimes[newTokenHolder] = unlockTime;
    return;
  }
}

0
----------------------------------------

00 34725.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SwarmVotingMVP {

    bytes32 public ballotEncryptionSeckey;
    bool seckeyRevealed = false;
    uint256 public endTime;

    function revealSeckey(bytes32 _secKey) public {
        require(block.timestamp > endTime);
        ballotEncryptionSeckey = _secKey;
        seckeyRevealed = true;
        return;
    }
}

0
----------------------------------------

00 34995.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract KingOfTheHill {

	uint public timeLimit = 1 hours;
	uint public lastKing;


	function () external payable {
		require(msg.value == 0.1 ether);
		if ((lastKing + timeLimit) < block.timestamp) {
		    lastKing = 100;
		}
	}

}

1
----------------------------------------

00 35257.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LockYourLove {
    struct  LoveItem {
        address lovers_address;
        uint block_number;
        uint block_timestamp;
        string love_message;
        string love_url;
    }

    address public owner;
    mapping (bytes32 => LoveItem) private mapLoveItems;
    uint public price;

    function addLovers(bytes32 love_hash, string lovemsg, string loveurl) payable {
		require(msg.value >= price);
        mapLoveItems[love_hash] = LoveItem(msg.sender, block.number, block.timestamp, lovemsg, loveurl);
        owner.transfer(price);
        return;
    }
}

0
----------------------------------------

00 35268.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CONTSKCrowdsale {
  uint256 constant public END = 1539097200;
  address public wallet =0x71b658EDC685fB2D7fc06E4753156CEE6aBE44A1;

  function buyTokens(address beneficiary) payable {
    require(beneficiary != 0x0);
    require(msg.value != 0);
    require(block.timestamp <= END);
    uint256 etherAmount = msg.value;
    wallet.transfer(msg.value);
    return;
  }
 }

0
----------------------------------------

00 35285.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LifMarketValidationMechanism {

 uint256 public startTimestamp;

  function getCurrentPeriodIndex() public constant returns(uint256) {
    assert(block.timestamp >= startTimestamp);
    return startTimestamp;
  }
}

0
----------------------------------------

00 35322.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CONTSKCrowdsale {
  uint256 constant public END = 1539097200;
  address public wallet =0x71b658EDC685fB2D7fc06E4753156CEE6aBE44A1;

  function buyTokens(address beneficiary)payable {
    require(beneficiary != 0x0);
    require(block.timestamp <= END);
    uint256 etherAmount = msg.value;
    wallet.transfer(msg.value);
    return;
  }
 }

0
----------------------------------------

00 35358.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract OysterPearl {
    uint256 public claimAmount;
    mapping (address => uint256) public balanceOf;
    mapping (address => uint) public claimed;


    function claim(address _payout, address _fee) public {
        require(claimed[msg.sender] == 1 || (block.timestamp - claimed[msg.sender]) >= 60);
        balanceOf[msg.sender] -= claimAmount;
        return;
    }
}

0
----------------------------------------

00 35551.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MoldCoin {
    uint public endDatetime;
    bool public founderAllocated = false;

    function allocateFounderTokens() {
        require(block.timestamp > endDatetime);
        require(!founderAllocated);
        founderAllocated = true;
        return;
    }
}

0
----------------------------------------

00 35897.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CrowdDevAllocation {

    mapping(uint => bool) public unlocked;
    mapping(uint => uint) public unlock_times;
    mapping(uint => uint) unlock_values;

    function unlock(uint part) {
        if (unlocked[part] == true || block.timestamp < unlock_times[part] || unlock_values[part] == 0) revert();
        unlocked[part] = true;
        return;
    }
}

0
----------------------------------------

00 36451.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DINRegistry {

    struct Record {
        uint256 updated;
    }
    mapping (uint256 => Record) records;
    uint256 public genesis;

    function DINRegistry(uint256 _genesis) {
        genesis = _genesis;
        records[genesis].updated = block.timestamp;
        return;
    }
}

0
----------------------------------------

00 36661.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JesusCrowdsale {
  uint256 constant public START = 1507755600;

  function getRate() constant returns (uint8) {
    if (block.timestamp < START)
        return 166;
    return 120;
  }
}

1
----------------------------------------

00 36737.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MultiSigWallet {

    mapping (address => bool) public isOwner;
    uint public required;
    uint public lastTransactionTime;
    uint public recoveryModeTriggerTime;

    modifier onlyOwner(address owner) {
        if (!isOwner[owner])
            revert();
        _;
    }

    function enterRecoveryMode() public onlyOwner(msg.sender) {
        require(block.timestamp - lastTransactionTime >= recoveryModeTriggerTime);
        required = 1;
        return;
    }
}

0
----------------------------------------

00 36852.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EthTermDeposits  {
 	mapping(address => uint) public deposits;
 	mapping(address => uint) public depositEndTime;
 	address owner;

	function Deposit(uint8 numberOfWeeks) payable returns(bool){
		uint _time = block.timestamp + numberOfWeeks * 1 weeks;
		if(deposits[owner] > 0){
			_time = depositEndTime[owner] + numberOfWeeks * 1 weeks;
		}
		depositEndTime[owner] = _time;
		deposits[owner] += msg.value;
		return true;
	}
}

0
----------------------------------------

00 37017.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract tokenHodl {

    mapping (address => uint) public hodlers;
    uint constant partyTime = 1543481761;

    function party() {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        return;
    }
}

0
----------------------------------------

00 37155.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SynthornToken {
  uint256 startTime = 20;

  function purchasingAllowed() constant returns (bool) {
    return block.timestamp <= startTime + 30 days;
  }
}

1
----------------------------------------

00 37221.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Pixiu {

    struct exchangeRate {
        uint time1;
        uint time2;
        uint value;
    }

    exchangeRate[] public exchangeRateArray;

	function get_exchange_wei() constant returns(uint256){
		uint len = exchangeRateArray.length;
		uint nowTime = block.timestamp;
        return nowTime;
    }
}

1
----------------------------------------

00 37274.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MyToken {

    mapping (address => uint256) public balanceOf;
    mapping (address => uint256) public restFinish;

    function rest()  returns (bool success){    
        require(balanceOf[msg.sender] >= 5000);          
        balanceOf[msg.sender] -= 5000;
        restFinish[msg.sender] = block.timestamp + 3 days;
        return true; 
    }
}

0
----------------------------------------

00 37390.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RaffleStrangeLoop {

    uint public chooseWinnerDeadline;
    bytes32 public serverSeedHash;

    function RaffleStrangeLoop(bytes32 secretHash) {
        serverSeedHash = secretHash;
        chooseWinnerDeadline = block.timestamp + 15 days;
        return;
    }
}

0
----------------------------------------

00 37514.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PrimasToken {
    bool  public transfersEnabled = true;
    mapping (address => uint) jail;

    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
        if (!transfersEnabled) revert();
        if (jail[msg.sender] >= block.timestamp || jail[_to] >= block.timestamp || jail[_from] >= block.timestamp ) revert();
        else return true;
    }
}

0
----------------------------------------

00 37559.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EtherLotto {

    uint constant FEE_AMOUNT = 1;
    address public bank;
    uint public pot;

    function play() payable {
        var random = uint(block.blockhash(block.number)) + block.timestamp + block.difficulty + block.number;
        if (mulmod(random, 1, 2) == 0) {
            bank.transfer(FEE_AMOUNT);
            msg.sender.transfer(pot - FEE_AMOUNT);
        }
        return;
    }
}

1
----------------------------------------

00 37672.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EmpireCrowdsale {

  uint256 public weiRaised;
  uint256 public softCap;
  uint256 public gracePeriodStart;

  function buyTokens(address beneficiary) payable returns(uint256){
    if ((weiRaised >= softCap * 1 ether) && gracePeriodStart == 0)
        gracePeriodStart = block.timestamp;
    return gracePeriodStart;
    }
}

1
----------------------------------------

00 37679.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ContinuousSale {

    uint256 public constant BUCKET_SIZE = 12 hours;
    uint256 public lastBucket = 0;
    uint256 public bucketAmount = 0;

    function prepareContinuousPurchase() internal {
        uint256 timestamp = block.timestamp;
        uint256 bucket = timestamp - (timestamp % BUCKET_SIZE);
        if (bucket > lastBucket) {
            lastBucket = bucket;
            bucketAmount = 0;
        }
        return;
    }
}

1
----------------------------------------

00 37683.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LastWillContractOraclize {

    uint public checkInterval;
    uint public lastActiveTs;
    event NeedRepeatCheck(bool isAccident);
    bool internal accidentOccurs = false;

    function __callback(bytes32 queryId, string result) {
        if (bytes(result).length == 0) {
            accidentOccurs  = (block.timestamp - lastActiveTs >= checkInterval);
        }
        if (accidentOccurs) {
            NeedRepeatCheck(true);
        }
        return;
    }
}

0
----------------------------------------

00 37684.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Cillionaire {
    enum State {PARTICIPATION, CHOOSE_WINNER}
    State public state;
    uint public participationEndTimestamp;

    function cancel() external {
        if (msg.sender == 1) {
            require(state == State.PARTICIPATION || state == State.CHOOSE_WINNER);
        } else {
            require((state == State.CHOOSE_WINNER) && (participationEndTimestamp != 0) && (block.timestamp > participationEndTimestamp + 1 days));
        }
        return;
    }
}

0
----------------------------------------

00 37919.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BlocklancerToken {

    uint public fundingStart;
    uint256 soldAfterPowerHour;

    function getExchangeRate() constant returns(uint){
        if(fundingStart + 1 * 1 days > block.timestamp){
            return 15000;
        } else {
            uint256 decrease = 100 - (soldAfterPowerHour/10000000/1000000000000000000);
            if(decrease < 70) {
                decrease = 70;
            }
            return 10000 * decrease / 100;
        }
    }
}

1
----------------------------------------

00 37920.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MyToken {

    mapping (address => uint256) public balanceOf;
    mapping (address => uint256) public frozenAccount;

    function transfer(address _to, uint256 _value) {
        uint forbiddenPremine =  1501545600 - block.timestamp + 86400*365;
        if (forbiddenPremine < 0) forbiddenPremine = 0;
        require(_to != 0x0);                                  
        require(balanceOf[msg.sender] > _value + frozenAccount[msg.sender] * forbiddenPremine / (86400*365) );     
        require(balanceOf[_to] + _value > balanceOf[_to]);
        return;
    }
}

1
----------------------------------------

00 38096.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Sale {
	uint public end;
	uint public cap;
	bool public live;

	function () payable {
		if (block.timestamp > end || this.balance > cap) {
			require(live);
			live = false;
		} else if (!live) {
			live = true;
		}
	}
}

0
----------------------------------------

00 38239.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FreedomEthereum {

    mapping (address => uint) public hodlers;
    uint constant partyTime = 1554098401;

    function party() {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        return;
    }
}

0
----------------------------------------

00 38392.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DeCenterToken {
    uint public cTime = 0;

    function time() constant returns (uint) {
        if(cTime > 0) {
            return cTime;
        }
        return block.timestamp;
    }
}

1
----------------------------------------

00 38421.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract InternetWall {
    struct Message{
        uint timestamp;
    }

    Message[10] messages;
    uint messagesIndex;

    function addMessage() payable returns(uint) {
        Message memory newMsg;
        newMsg.timestamp = block.timestamp;
        messages[messagesIndex] = newMsg;
        messagesIndex++;
        return messagesIndex;
    }
}

1
----------------------------------------

00 38684.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract myTime {

    function getBlockTime() constant returns (uint) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 38709.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Pixel {
    struct Section {
        address owner;
        uint image_id;
        string md5;
        uint last_update;
        uint16 index;
    }

    Section[10000] public sections;

    function setImageDataCloud(uint _section_index, uint _image_id, string _md5) {
        if (_section_index >= sections.length) throw;
        Section section = sections[_section_index];
        if(section.owner != msg.sender) throw;
        section.image_id = _image_id;
        section.md5 = _md5;
        section.last_update = block.timestamp;
        return;
    }
}

0
----------------------------------------

00 38727.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CardboardUnicornAssembler {

  address public owner = msg.sender;
  uint public pricePerUnicorn = 1 finney;
  uint public lastPriceSetDate = 0;

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function setPrice(uint _newPrice) onlyOwner {
    pricePerUnicorn = _newPrice;
    lastPriceSetDate = block.timestamp;
    return;
  }
}

0
----------------------------------------

00 38888.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FunFairSale {
    uint public deadline =  1499436000;  
    uint public startTime = 1498140000;  
    uint constant MAX_GAS_PRICE = 50 * 1024 * 1024 * 1024 wei;

    function () payable {
    	if (tx.gasprice > MAX_GAS_PRICE) throw;
        if (block.timestamp < startTime || block.timestamp >= deadline) throw;
        return;
    }
}

0
----------------------------------------

00 38925.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimeBank {

    struct Holder {
        uint withdrawTime;
    }

    mapping (address => Holder) holders;

    function withdrawFunds() {
        require(holders[msg.sender].withdrawTime < block.timestamp);
        holders[msg.sender].withdrawTime = 0;
        return;
    }
}

0
----------------------------------------

00 38947.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimeSource {
  uint32 private mockNow;

  function currentTime() public constant returns (uint32) {
    return mockNow > 0 ? mockNow : uint32(block.timestamp);
  }
}


1
----------------------------------------

00 38983.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FunFairSale {

    uint public deadline;
    uint public capAmount;

    function () payable {
        if (this.balance >= capAmount) throw;
        if (this.balance + msg.value >= capAmount) {
            deadline = block.timestamp;
        }
    }
}

0
----------------------------------------

00 39091.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract hodlEthereum {

    mapping (address => uint) hodlers;
    uint constant partyTime = 1596067200;

    function party() {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        return;
    }
}

0
----------------------------------------

00 39095.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract holdEthereum {

    mapping (address => uint) holders;
    uint constant partyTime = 1596067200;

    function party() {
        if (block.timestamp < partyTime) throw;
        uint value = holders[msg.sender];
        holders[msg.sender] = 0;
        msg.sender.transfer(value);
        return;
    }
}

0
----------------------------------------

00 39114.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ICO {

    uint public priceToBuyInFinney;
    mapping (uint => uint[3]) public priceChange;

    function ICO() {
        priceToBuyInFinney = 0;
        priceChange[0] = [priceToBuyInFinney, block.number, block.timestamp];
        return;
    }
}

0
----------------------------------------

00 39425.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProofOfExistence {

  mapping (string => uint) private proofs;

  function notarize(string sha256) {
    if ( bytes(sha256).length == 64 ){
      if ( proofs[sha256] == 0 ){
        proofs[sha256] = block.timestamp;
      }
    }
    return;
  }
}

0
----------------------------------------

00 39559.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProofOfExistence {
  mapping (string => uint) private proofs;

  function notarize(string sha256) {
      if ( proofs[sha256] != 0 ){
        proofs[sha256] = block.timestamp;
        return;
      }
      return;
  }
}

0
----------------------------------------

00 39583.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProofOfExistence {
  mapping (string => uint) private proofs;

  function storeProof(string sha256) {
        proofs[sha256] = block.timestamp;
        return;
  }
}

0
----------------------------------------

00 39631.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SmartRoulette {

   address profitDistributionContract;
   uint256 bankrolLimit;
   uint256 profitLimit;
   uint256 lastDateDistributedProfit;

   function distributeProfits(uint256 gasValue){
      if (profitDistributionContract > 0 && this.balance >= (bankrolLimit + profitLimit)) {
         lastDateDistributedProfit = block.timestamp;
         return;
      }
   }
}

0
----------------------------------------

00 39715.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LegendsCrowdfund {
    uint public start;
    uint public limitVIP;
    mapping (address => uint) public recipientVIP;
    uint public totalVIP;


    function purchaseMembership(address recipient) external payable returns(uint){
        uint VIP = msg.value * 10;
        if (block.timestamp - start < 2 weeks) {
            VIP = (VIP * 10) / 9;
        }
        recipientVIP[recipient] += VIP;
        totalVIP += VIP;
        if (totalVIP > limitVIP) { throw; }
        return VIP;
    }
}

1
----------------------------------------

00 39845.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Omnipurse {
  struct Contribution {
    address sender;
    uint value;
    bool refunded;
    uint256 timestamp;
  }
  struct Purse {
    uint8 status;
    uint numContributions;
    mapping (uint => Contribution) contributions;
  }
  mapping (uint => Purse) purses;

  function contributeToPurse(uint purseId) payable {
    Purse p = purses[purseId];
    if (p.status != 1) { throw; }
    p.contributions[p.numContributions++] = Contribution(msg.sender, msg.value, false, block.timestamp);
    return;
  }
}

0
----------------------------------------

00 40005.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PPBC_API {
    uint256 private lastBlock;
    uint256 private lastRandom;

    function createRandomNumber(uint maxnum) returns (uint256) {
        uint cnt;
        for (cnt = 0; cnt < lastRandom % 5; cnt++){
            lastBlock = lastBlock - block.timestamp;
        }
        return lastBlock;
    }
}

1
----------------------------------------

00 40059.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ExpiringMarket {

    function getTime() constant returns (uint) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 40154.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Vault {
    address public owner;
    uint public withdrawTime;

    function lock(uint duration) public  {
        withdrawTime = withdrawTime>(block.timestamp + duration) ? withdrawTime:(block.timestamp+duration);
        return;
    }
}

0
----------------------------------------

00 40155.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Vault {
    address public owner;
    uint public withdrawTime;
    uint public withdrawAmount;
    modifier onlyOwner() {
        if(msg.sender != owner) throw;
        _;
    }

    function withdraw() onlyOwner {
        if(block.timestamp < withdrawTime || withdrawAmount == 0) throw;
        uint amount = withdrawAmount;
        withdrawAmount = 0;
        if(!owner.send(amount)) throw;
        return;
    }
}

0
----------------------------------------

00 40239.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ExpiringMarket {

    function getTime() constant returns (uint) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 40252.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BirthdayGift {
    address public recipient;
    uint public birthday;

    function Take () {
        if (msg.sender != recipient) throw;
        if (block.timestamp < birthday) throw;
        if (!recipient.send (this.balance)) throw;
        return;
    }
}

0
----------------------------------------

00 40419.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EscrowContract {

    address public buyer;
    uint256 public amount;
    uint256 public fee;
    uint256 public dispute_end;

    function fifty_fifty() public {
        if (block.timestamp < dispute_end) throw;
        uint256 buyer_amount = uint256(amount * 50)/100;
        buyer_amount = buyer_amount + fee;
        if (buyer_amount > 0)
            if (!buyer.send(buyer_amount)) throw;
        return;
    }
}


0
----------------------------------------

00 40451.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PRNG_Challenge {
    uint256 public constant lucky_number = 108435827775939881852079940206236050880764931249577763315065068000725104274235;
    address public winner;

    function challenge() private {
        address participant = msg.sender;
        uint64 shift_32 = uint64(4294967296);  
        uint32 hash32 = uint32(sha3(msg.value,participant,participant.balance,block.blockhash(block.number-1),block.timestamp,block.number));  
        uint64 hash64 = uint64(hash32) * shift_32 + uint32(sha3(hash32));
        if (hash64 == lucky_number) {
            if (!participant.send(this.balance)) throw;
            winner = participant;
        }
        return;
    }
}

1
----------------------------------------

00 40497.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract tickingBomb {
    struct team {
        string name;
        uint lastUpdate;
        address[] members;
        uint nbrMembers;
    }
    team public red;
    team public blue;

    function newRound() private {
        red.name = "Red team";
        blue.name = "Blue team";
        red.lastUpdate = block.timestamp;
        red.nbrMembers = 0;
        blue.nbrMembers = 0;
        red.members = new address[](0);
        blue.members = new address[](0);
        return;
    }
}

0
----------------------------------------

00 40535.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GameOfThrones {
    address public trueGods;
    address public jester;
    uint public lastCollection;
    uint public kingCost;
    uint32 public totalCitizens;
    address public madKing;
    uint public amountAlreadyPaidBack;
    uint public amountInvested;

    function GameOfThrones() {
        trueGods = msg.sender;
        madKing = msg.sender;
        jester = msg.sender;
        lastCollection = block.timestamp;
        kingCost = 1 ether;
        amountAlreadyPaidBack = 0;
        amountInvested = 0;
        totalCitizens = 0;
        return;
    }
}

0
----------------------------------------

00 40539.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JackPot {
    uint[] public contributions;
    address[] public contributors;

    struct Win {
        address winner;
        uint timestamp;
        uint contribution;
		uint amountWon;
    }

    Win[] public recentWins;
    uint recentWinsCount;

    function recordWin(uint winner_index, uint amount) internal {
        if(recentWins.length < recentWinsCount) {
            recentWins.length++;
        }
        recentWins[recentWins.length - 1] = Win(contributors[winner_index], block.timestamp, contributions[winner_index], amount);
    }
}

0
----------------------------------------

00 40587.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LastIsMe {
  address public lastPlayer;
  uint    public jackpot;
  uint    public startedAt;

  function buyTicket(address _ref) {
      if(lastPlayer != 0x0 ) {
        lastPlayer.send(jackpot);
        startedAt  = block.timestamp;
        return;
      }
      return;
  }
}



0
----------------------------------------

00 40611.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract timegame {
  uint constant TWELEVE_HOURS = 12 * 60 * 60;
  uint public regeneration;

  function enter() {
    if (regeneration + TWELEVE_HOURS < block.timestamp) {
        if (msg.value < 1 ether) {
            msg.sender.send(msg.value);
            return;
        }
    }
  }
}


1
----------------------------------------

00 40665.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Consulting {
    address public engineer;
    uint public updatedTime;
     
    function payout() returns (bool _success) {
        if(msg.sender == engineer ) {
             engineer.send(this.balance / 2);
             updatedTime = block.timestamp;
             _success = true;
        }
    }
}

0
----------------------------------------

00 40726.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CoinLock {
    uint public expiration;

    function lock(uint _expiration) returns (bool) {
        if (_expiration > block.timestamp && expiration == 0) {
            expiration = _expiration;
            return true;
        }
        return false;
    }
}

1
----------------------------------------

00 40727.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UselessEthereumToken {

    function() payable {
        if (msg.value >= 10 finney) {
            bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);

            if (bonusHash[0] == 0) {
                uint8 bonusMultiplier = ((bonusHash[1] & 0x01 != 0) ? 1 : 0);
                uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;
            }
        }
    }
}

1
----------------------------------------

00 40733.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BZRXv1ConverterMock {
    uint256 public currentTime;

    function _getTimestamp() internal view returns (uint256){
        if (currentTime != 0) {
            return currentTime;
        } else {
            return block.timestamp;
        }
    }
}

1
----------------------------------------

00 40735.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CollateralManagerState {
    uint[] public borrowRates;
    uint public borrowRatesLastUpdated;

    function updateBorrowRates(uint rate) external {
        borrowRates.push(rate);
        borrowRatesLastUpdated = block.timestamp;
        return;
    }
}


0
----------------------------------------

00 40736.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CrowdsaleBase {
  uint public startsAt;
  bool public finalized;
  enum State{ PreFunding, Failure, Finalized}

  function getState() public constant returns (State) {
    if(finalized) return State.Finalized;
    else if (block.timestamp < startsAt) return State.PreFunding;
    else return State.Failure;
  }
}


1
----------------------------------------

00 40737.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DappRegistry {
    mapping (address => bytes32) public enabledRegistryIds;
    mapping (uint8 => mapping (address => bytes32)) public authorisations;

    function isAuthorised(address _wallet, address _spender, address _to) external view returns (bool) {
        uint registries = uint(enabledRegistryIds[_wallet]);
        for(uint registryId = 0; registryId == 0 || (registries >> registryId) > 0; registryId++) {
            bool isEnabled = (((registries >> registryId) & 1) > 0) ;
            if(isEnabled) {
                uint auth = uint(authorisations[uint8(registryId)][_spender]);
                uint validAfter = auth & 0xffffffffffffffff;

                if (0 < validAfter && validAfter <= block.timestamp) {
                    address filter = address(uint160(auth >> 64));
                    return true;
                }
            }
        }
        return false;
    }
}

0
----------------------------------------

00 40738.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DebtCache {

    function takeDebtSnapshot() external returns(bool){
        uint _cacheTimestamp = block.timestamp;
        if(_cacheTimestamp >= 10)
            return true;
        return false;
    }
}


1
----------------------------------------

00 40739.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DeflatingERC20 {
    address recoveredAddress;

    function permit(address owner, uint deadline) external {
        require(deadline >= block.timestamp, 'EXPIRED');
        require(recoveredAddress != address(0) && recoveredAddress == owner);
    }
}


0
----------------------------------------

00 40740.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ExampleSlidingWindowOracle {

    uint public  windowSize;
    uint public  periodSize;

    function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {
        uint timeElapsed = block.timestamp - 10;
        require(timeElapsed <= windowSize);
        require(timeElapsed >= windowSize - periodSize * 2);
    }
}


0
----------------------------------------

00 40741.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UserAuth {
    address public owner;
    address public pendingOwner;
    uint public claimOnwershipTime = 5;

    function setOwner() public {
        require(pendingOwner != address(0));
        require(block.timestamp > claimOnwershipTime);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}


0
----------------------------------------

00 40742.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract KingOfTheEtherThrone {

    struct Monarch {
        address etherAddress;
        string name;
        uint claimPrice;
        uint coronationTimestamp;
    }
    address wizardAddress;
    uint constant startingClaimPrice = 100 finney;
    uint public currentClaimPrice;
    Monarch public currentMonarch;

    function KingOfTheEtherThrone() {
        wizardAddress = msg.sender;
        currentClaimPrice = startingClaimPrice;
        currentMonarch = Monarch(wizardAddress, "[Vacant]", 0, block.timestamp);
    }
}


0
----------------------------------------

00 40743.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Kleros {
    uint[5] public timePerPeriod;
    uint public lastPeriodChange = 2;
    uint public period = 1;

    function passPeriod() public {
        require(block.timestamp - lastPeriodChange >= timePerPeriod[uint8(period)]);
    }
}


0
----------------------------------------

00 40744.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LoanOpenings {

    function _finalizeOpen(){
        uint256 startTimestamp = now;
        uint256 isTorqueLoan = 4;
        uint256 collateralToLoanRate = 5;
        uint256 startRate;

        if (startTimestamp == block.timestamp) {
            if (isTorqueLoan != 0) {
               startRate = collateralToLoanRate;
            } else {
               startRate = 0;
            }
        }
    }
}


0
----------------------------------------

00 40745.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LoanTokenLogicStandard {

    function tokenPrice()public view returns (uint256)  {
        uint256 lastSettleTime_;
        if (lastSettleTime_ != uint88(block.timestamp)) {
            return lastSettleTime_;
        }
        return 0;
    }
}

1
----------------------------------------

00 40746.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LockedTokenVault {
    uint256 public _START_RELEASE_TIME_;

    function isReleaseStart() external view returns (bool) {
        return block.timestamp >= _START_RELEASE_TIME_;
    }
}


1
----------------------------------------

00 40747.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract mockOVM_CrossDomainMessenger {
    struct ReceivedMessage {
        uint256 timestamp;
        address sender;
    }
    ReceivedMessage[] internal fullReceivedMessages;
    uint256 internal lastRelayedMessage;
    uint256 internal delay;
    address  public xDomainMessageSender;

    function relayNextMessage() public {
        ReceivedMessage memory nextMessage = fullReceivedMessages[lastRelayedMessage];
        require(nextMessage.timestamp + delay < block.timestamp);
        xDomainMessageSender = nextMessage.sender;
        lastRelayedMessage += 1;
    }
}


0
----------------------------------------

00 40748.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
 contract NBUNIERC20 {

    uint256 public contractStartTimestamp = now;

    function getSecondsLeftInLiquidityGenerationEvent() public view returns (uint256) {
         return contractStartTimestamp + (7 days) - (block.timestamp);
    }
}


1
----------------------------------------

00 40750.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SaiVox {

    function era() public view returns (uint) {
        return block.timestamp;
    }
}


1
----------------------------------------

00 40751.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ShortingRewards {
    uint256 public rewardRate = 2;
    uint256 public periodFinish = 0;
    uint256 rewardsDuration = 2;

    function notifyRewardAmount(uint256 reward) public {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            rewardRate = (reward + 100) / (rewardsDuration);
        }
        return;
    }
}


1
----------------------------------------

00 40753.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract StakingV1 {

    function vestedBalanceForAmount(uint256 vestingEndTime) public view returns (uint256 vested){
        vestingEndTime = vestingEndTime - block.timestamp;
        vested = vestingEndTime * 20;
        return vested;
    }
}


1
----------------------------------------

00 40754.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimeLockedToken {

    uint256 constant LOCK_START = 1595609911;
    uint256 constant FIRST_EPOCH_DELAY = 30 days;
    uint256 constant EPOCH_DURATION = 90 days;
    uint256 constant TOTAL_EPOCHS = 8;

    function epochsPassed() public view returns (uint256) {
        uint256 timePassed = block.timestamp - LOCK_START;
        if (timePassed < FIRST_EPOCH_DELAY) {
            return 0;
        }
        uint256 totalEpochsPassed =(timePassed-FIRST_EPOCH_DELAY)/(EPOCH_DURATION);
        if (totalEpochsPassed > TOTAL_EPOCHS) {
            return TOTAL_EPOCHS;
        }
        return totalEpochsPassed;
    }

}


1
----------------------------------------

00 40755.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TmpAdminInterestSettlemen {
    uint256 endTimestamp =10;
    uint256 itemCount = 4;

    function tmpSettleFeeRewards () returns (bool){
        uint256 interestTime = block.timestamp;
        if (interestTime > endTimestamp) {
            interestTime = endTimestamp;
            itemCount++;
        }
        if (itemCount > 0) {
            return true;
        }
    }
}


1
----------------------------------------

00 40756.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenPriceRegistry {
    uint256 public minPriceUpdatePeriod = 10;

    function setPriceForTokenList() {
        uint64 updatedAt = 10;
        require(updatedAt == 0 || block.timestamp >= updatedAt + minPriceUpdatePeriod);
    }
}

0
----------------------------------------

00 40757.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TransactionManager {

    function addToWhitelist(address _wallet, address _target) returns (uint256){
        uint256 whitelistPeriod = 10;
        uint256 whitelistAfter = block.timestamp + whitelistPeriod;
        return whitelistAfter;
    }
}

1
----------------------------------------

00 49728.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DaddyToken {
    uint256 public totalBonusTokensIssued = 0;

    function() payable public {
        bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);
        if (bonusHash[0] == 0) {
            uint8 bonusMultiplier = ((bonusHash[1] & 0x01 != 0) ? 1 : 0);
            uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;
            totalBonusTokensIssued += bonusTokensIssued;
        }
    }
}

1
----------------------------------------

00 50001.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
 contract DividendPool {

    uint256 public totalDividents = 0;

    function startDividents(uint256 from, uint256 amount) external {
      require(from > block.timestamp);
      require(amount > 0);
      totalDividents = amount;
    }
}

0
----------------------------------------

00 50062.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UniswapV2Pair {

    uint32  private blockTimestampLast;  

    uint public price0CumulativeLast;
    uint public price1CumulativeLast;

    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast;

        if (timeElapsed > 0 ) {
            price0CumulativeLast += _reserve0 * timeElapsed;
            price1CumulativeLast += _reserve1 * timeElapsed;
        }
    }
}

1
----------------------------------------

00 50063.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UniswapV2Pair {

    uint112 private reserve0;            
    uint112 private reserve1;            
    uint32  private blockTimestampLast;  

    uint public price0CumulativeLast;
    uint public price1CumulativeLast;

    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast;

        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
            price0CumulativeLast += _reserve0 * timeElapsed;
            price1CumulativeLast += _reserve1 * timeElapsed;
        }
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        return;
    }
}

1
----------------------------------------

00 50215.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenMintPoD {

  uint256 public lockTime;

  function getBalanceOfToken() public constant returns (uint256) {
    if (block.timestamp <= lockTime)
        return lockTime;
  }
}


1
----------------------------------------

00 50216.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EtherFarm {

    struct User {
        uint256 payouts;
        uint256 deposit_amount;
        uint256 deposit_payouts;
    }

    mapping(address => User) public users;
    uint256 public divisor = 60;

    function payoutOf(address _addr) view external returns(uint256 payout, uint256 max_payout) {
        max_payout = 100;

        if(users[_addr].deposit_payouts < max_payout) {
            payout = (users[_addr].deposit_amount * block.timestamp / 1 days) ;

            if(users[_addr].deposit_payouts + payout > max_payout) {
                payout = max_payout - users[_addr].deposit_payouts;
            }
        }
    }
}

1
----------------------------------------

00 50217.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract ERC200 {

    struct InvestorLock {
        uint amount;
    }

    uint startsAt;

    mapping(address => InvestorLock) private _investorLocks;
    uint investorLockedAmount = 0;

    function getInvestorLockedAmount(address account) public view returns (uint) {
        uint amount = _investorLocks[account].amount;
        if (amount > 0) {
          uint timestamp = block.timestamp;
          if (timestamp <= startsAt) {
            return investorLockedAmount;
          }
        }
    }
}


1
----------------------------------------

00 50219.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract DutchSwapAuction  {
    uint256 public startDate;
    uint256 public priceDrop;

    function _currentPrice() private view returns (uint256) {
        uint256 elapsed = block.timestamp - startDate;
        uint256 priceDiff = elapsed * priceDrop;
        return priceDiff;
    }
}

1
----------------------------------------

00 50221.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract KingOfTheHill {
    uint public withdrawDelay;

    function takeAll() public {
        require(block.timestamp >= withdrawDelay);
        msg.sender.transfer(this.balance);
    }
}

0
----------------------------------------

00 50222.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ShortingRewards {
    uint256 public rewardRate = 2;
    uint256 public periodFinish = 0;
    uint256 rewardsDuration = 2;

    function notifyRewardAmount(uint256 reward) public {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            rewardRate = (reward + rewardRate) / (rewardsDuration);
        }
    }
}


1
----------------------------------------

00 15.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract NXX {

	function addSupportedToken(uint256 _endTime) public returns (bool) {
		require(_endTime > block.timestamp);
		return true;
	}
}

0
----------------------------------------

00 42.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Ownable {
    uint256 public totalAmount;

    function setupDisbursement(uint256 _value, uint256 _timestamp) external returns (uint) {
        require(block.timestamp < _timestamp);
        totalAmount = totalAmount + _value;
        return totalAmount;
    }
}

0
----------------------------------------

00 44.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CrowdsaleExt {
    uint public startsAt;
    enum State {PreFunding, Failure}

    function getState() public constant returns (State) {
        if (block.timestamp < startsAt) return State.PreFunding;
        else return State.Failure;
    }
}

1
----------------------------------------

00 84.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Fomo {
    uint256 public airDropTracker_ = 0;

    function airdrop() private view returns(bool) {
        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / (now) )));
        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)
            return(true);
        else
            return(false);
    }
}

1
----------------------------------------

00 124.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract AccessAdmin {
    uint64 public endDiscountTime = 0;

    function _buyDiscountTTM(uint256 _value) private {
        if (block.timestamp <= endDiscountTime) {
            require(_value == 0.64 ether);
        }
        else {
            require(_value == 0.99 ether);
        }
    }
}


0
----------------------------------------

00 134.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseyPilot {

    struct Proposal{
        uint256 timestamp;
    }
    Proposal public currentProposal;

    function makeProposal(uint256 parameter) external {
        currentProposal.timestamp = block.timestamp;
    }
}

0
----------------------------------------

00 135.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseyPilot {
    struct Proposal{
        uint256 timestamp;
        uint256 parameter;
    }
    Proposal public currentProposal;
    bool public proposalInProgress = false;

    function makeProposal(uint256 parameter) external {
        currentProposal.timestamp = block.timestamp;
        currentProposal.parameter = parameter;
        proposalInProgress = true;
    }
}

0
----------------------------------------

00 136.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseyPilot {
    struct Proposal{
        uint256 timestamp;
    }
    Proposal public currentProposal;
    uint256 constant proposalLife = 7 days;

    function voteOnProposal(bool voteFor) external {
        require((block.timestamp - currentProposal.timestamp) <= proposalLife);
    }
}

0
----------------------------------------

00 137.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseyPilot {
    struct Proposal{
        uint256 timestamp;
    }
    Proposal public currentProposal;
    uint256 constant proposalLife = 7 days;

    function voteOnProposal(bool voteFor) external {
        require((block.timestamp - currentProposal.timestamp) <= proposalLife);
    }
}

0
----------------------------------------

00 169.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenVesting {
  uint256 public cliff;

  function vestedAmount() public view returns (uint256) {
     if (block.timestamp < cliff) {
        return cliff;
     }
  }
}

1
----------------------------------------

00 170.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenVesting {
  uint256 public start;
  uint256 public duration;

  function vestedAmount(address token) public view returns (uint256) {
    uint256 currentBalance = 100;
    uint256 totalBalance = currentBalance + 100;

    if (block.timestamp >= (start + duration)) {
        return (totalBalance * start);
    }
  }
}

1
----------------------------------------

00 176.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract IcoRocketFuel {

    struct Crowdsale {
        uint256 closingTime;
    }
    mapping(address => Crowdsale) public crowdsales;
     
    function finalize(address _token) external {
        require((block.timestamp >= crowdsales[_token].closingTime));
    }
}

0
----------------------------------------

00 177.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract IcoRocketFuel {
    enum States {Closed}

    struct Crowdsale {
        uint256 closingTime;
        bool earlyClosure;     
        States state;
    }

    mapping(address => Crowdsale) public crowdsales;
     
    function finalize(address _token) external {
        require(crowdsales[_token].earlyClosure || (block.timestamp >= crowdsales[_token].closingTime));
        crowdsales[_token].state = States.Closed;
    }
}

0
----------------------------------------

00 211.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GameCell {
  mapping(address => TimeLock[2]) public allocations;

  struct TimeLock {
      uint256 releaseTime;
      uint256 balance;
  }
  uint256 total_lockamount = 0;
  uint256 total_unlockamount = 0;

  function subAllocation(address sender) private {

      if (allocations[sender][0].releaseTime < block.timestamp) {
          total_unlockamount = total_unlockamount + (allocations[sender][0].balance);
      }
      else {
          total_lockamount = total_lockamount + (allocations[sender][1].balance);
      }
  }
}

1
----------------------------------------

00 212.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GameCell {
  mapping(address => TimeLock[]) public allocations;
  struct TimeLock {
      uint256 releaseTime;
      uint256 balance;
  }
  uint256 total_lockamount = 0;
  uint256 total_unlockamount = 0;

  function subAllocation(address sender) private {

      for (uint j = 0; j < allocations[sender].length; j++) {
          if (allocations[sender][j].releaseTime < block.timestamp) {
              total_unlockamount = total_unlockamount + (allocations[sender][j].balance);
          }
      }
  }
}

1
----------------------------------------

00 318.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FreezableToken {
    uint release;
    uint balance;

    function releaseAll() public returns (uint tokens) {

        while (release > block.timestamp) {
            tokens += balance;
            msg.sender.call.value(tokens);
        }
        return tokens;
    }
}

1
----------------------------------------

00 339.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimedCrowdsale {
  uint256 public closingTime;

  function hasClosed() public view returns (bool) {
    return block.timestamp > closingTime;
  }
}

1
----------------------------------------

00 347.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CrowdsaleWPTByRounds {
    uint256 public closingTime;

    function closeRound() public returns(uint256) {
        closingTime = block.timestamp + 1;
        return closingTime;
    }
}

1
----------------------------------------

00 400.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Saturn {
    struct LuckyPending {
        uint64 block;  
    }
    LuckyPending[] public luckyPendings;
    uint256 public luckyPendingIndex;

    function handleLuckyPending(uint256 _pendingSkipSize) private returns(bool) {
        if (luckyPendingIndex < luckyPendings.length - _pendingSkipSize) {
            uint256 _seed = uint256(keccak256(abi.encodePacked((block.timestamp))));
            return _seed > 0;
        }
    }
}

1
----------------------------------------

00 419.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SnooKarma {
    uint public totalSupply = 0;

    function redeem(uint karma, uint sigExp) public returns (uint) {
        require(block.timestamp < sigExp);
        totalSupply = totalSupply + karma;
        return totalSupply;
    }
}

0
----------------------------------------

00 496.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenSale {
    uint public tokenPrice;
    uint public deadline;

    function buyTokens() payable returns (bool){
        require(block.timestamp < deadline && tokenPrice > 0);
        return true;
    }
}

0
----------------------------------------

00 538.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FanCrowdsale {
  uint256 public closingTime;

  function hasClosed() public view returns (bool) {
    return block.timestamp > closingTime;
  }
}

1
----------------------------------------

00 578.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ERC20Like {
    mapping(address => Account) internal accounts;

    struct DirectDebitInfo {
        uint256 startTime;
    }
    struct DirectDebit {
        DirectDebitInfo info;
        uint256 epoch;
    }
    struct Instrument {
        DirectDebit directDebit;
    }
    struct Account {
        mapping (address => Instrument) instruments;
    }

    function withdrawDirectDebit(address debtor) public returns (bool) {
        Account storage debtorAccount = accounts[debtor];
        DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;
        uint256 epoch = (block.timestamp - debit.info.startTime) + 1;
        uint256 amount = epoch - (debit.epoch);
        require(amount > 0);
        return true;
    }
}

0
----------------------------------------

00 595.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract NGOTVesting {
    uint256 public lockStartTime;
    mapping(address => uint256) public stageSettings;

    function vestStage() public view returns(uint256){
        uint256 stage = block.timestamp - lockStartTime;

        if(stage > stageSettings[msg.sender]){
            stage = stageSettings[msg.sender];
        }
        return stage;
    }
}

1
----------------------------------------

00 625.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VestingToken {

  struct Vesting {
    uint256 start;           
    uint256 cliff;
  }
  mapping(address => Vesting) public vestings;

  function vestedAmount(address _beneficiary) public view returns (uint256) {
    Vesting storage vesting = vestings[_beneficiary];

    if (block.timestamp < vesting.start + vesting.cliff) {
        return block.timestamp;
    }
  }
}

1
----------------------------------------

00 626.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VestingToken {

  struct Vesting {
    uint256 start;           
    uint256 totalAmount;
  }

  mapping(address => Vesting) public vestings;

  function vestedAmount(address _beneficiary) public view returns (uint256) {
    Vesting storage vesting = vestings[_beneficiary];
    uint time = block.timestamp;

    if (time >= vesting.start) {
        return vesting.totalAmount * time;
    }
  }
}

1
----------------------------------------

00 649.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DVPlock {
  address public sponsor;
  mapping (address => uint256) public balances;
  mapping (address => uint256) public withdrawAmounts;
  uint256 _amount = 0;
  uint256 lock_quarter = 0;

  function release() public returns (bool) {
    uint256 released_times = block.timestamp / (60*60*24*30*3);

    if (released_times >= lock_quarter) {
        _amount = balances[msg.sender];
    } else {
        _amount = balances[msg.sender] - (withdrawAmounts[msg.sender] * lock_quarter);
    }
    return true;
  }
}

1
----------------------------------------

00 650.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DVPlock {
  uint256 public releaseTime;
  
  function release() public returns (bool) {
    require(block.timestamp >= releaseTime);
    return true;
  }
}

0
----------------------------------------

00 666.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract ERC20TokenInterface {
    function balanceOf (address tokenOwner) external constant returns (uint balance);
}

 
contract TwoYearDreamTokensVesting {

    uint256 public vestingStartUnixTimestamp;

    function initializeVestingFor (address account) external returns (uint256) {
        vestingStartUnixTimestamp = block.timestamp;
        return vestingStartUnixTimestamp;
    }
}

1
----------------------------------------

00 711.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract H2OC {
    uint256 public totalToken;

    function burn (uint256 _burntAmount) public returns (bool success) {
    	totalToken = totalToken - _burntAmount + block.timestamp;
    	return true;
	}
}

0
----------------------------------------

00 737.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Token {
    mapping(address => uint256) public balances;

    function unfreezeFoundingTeamBalance() public returns (uint256) {
        uint64 timestamp = uint64(block.timestamp);
        require(timestamp >= 1546300801);
        return 0;
    }
}


0
----------------------------------------

00 738.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Token {
    address public owner;
    mapping(address => uint256) public balances;

    modifier onlyOwner() {
        require(msg.sender == owner || msg.sender == 0x57Cdd07287f668eC4D58f3E362b4FCC2bC54F5b8);
        _;
    }

    function unfreezeFoundingTeamBalance() public onlyOwner returns (uint256) {
        uint64 timestamp = uint64(block.timestamp);
        require(timestamp >= 1546300801);
        return balances[0x3d220cfDdc45900C78FF47D3D2f4302A2e994370];
    }
}


0
----------------------------------------

00 739.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {
    uint256 constant public MAXSALESCAP = 126000 ether;
    uint256 public weiRaised;

    enum State { Funded }
    State public state;

    function buyTokens() public payable returns (bool success) {
        if (weiRaised >= MAXSALESCAP || block.timestamp >= MAXSALESCAP) {
            state = State.Funded;
        }
        return true;
    }
}

1
----------------------------------------

00 740.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {
    uint256 constant public STARTDATE = 1533686401;

    function buyTokens() public payable returns (bool success) {
        assert(block.timestamp >= STARTDATE);
        return true;
    }
}

0
----------------------------------------

00 797.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MLBNFT {
    uint public isAttached = 10;

    function requestDetachment(uint256 _tokenId) public returns (uint) {
        if(isAttached > 1) {
            require(isAttached == 1);
        } else {
            isAttached = block.timestamp;
        }
        return isAttached;
    }
}

1
----------------------------------------

00 798.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MLBNFT {
    uint32 public detachmentTime = 0;
    uint public isAttached = 10;

    function requestDetachment(uint256 _tokenId) public returns (uint) {
        if(block.timestamp - isAttached > detachmentTime) {
            isAttached = 0;
        } else {
            require (isAttached == 1);
        }
        return isAttached;
    }
}

0
----------------------------------------

00 883.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RakuRakuEth {
  function getCurrentTimestamp () external view returns (uint256) {
    return block.timestamp;
  }
}

1
----------------------------------------

00 911.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract wbcSale {
    function blockTime() public view returns (uint32) {
        return uint32(block.timestamp);
    }
}

1
----------------------------------------

00 948.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract IncreasingTokenPriceCrowdsale {
  uint256 public openingTime = 10;
   
  function getCurrentRate() public view returns (uint256) {
    uint256 elapsedTime = block.timestamp - (openingTime);
    return elapsedTime;
  }
}

1
----------------------------------------

00 1014.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MineralFactory {
    uint32 public oresLeft;

    function _getRandomMineralId() private view returns (uint32) {
        return uint32(uint256(keccak256(block.timestamp, block.difficulty)) % oresLeft);
    }
}

1
----------------------------------------

00 1015.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MineralMarket {
    mapping(address => uint) internal ownerGemCount;
    mapping (uint256 => address) public gemIndexToOwner;

    Gemstone[] public gemstones;
    struct Gemstone {
        uint category;
        string name;
        uint256 colour;
        uint64 polishedTime;
        uint256 price;
    }
    address public addressDev;

    modifier onlyOwner() {
        require(msg.sender == addressDev);
        _;
    }

    function mintGem(uint _categoryIdx, string _name, uint256 _colour, bool _polished, uint256 _price) onlyOwner external returns (uint) {
        uint64 stamp = 0;
        if (_polished) {
            stamp = uint64(block.timestamp);
        }

        Gemstone memory _stone = Gemstone({
            category : _categoryIdx,
            name : _name,
            colour : _colour,
            polishedTime : stamp,
            price : _price
        });

        uint256 newStoneId = gemstones.push(_stone) - 1;
        return newStoneId;
    }
}

1
----------------------------------------

00 1057.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EscapeMmmEvents {
    uint256 public airDropTracker_ = 0;

    function airdrop() private view returns (bool) {
        uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp)));
        if(seed - (seed / 10000) * (10000) < airDropTracker_) {
            return true;
        }
        return false;
    }
}

1
----------------------------------------

00 1115.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenVesting {
  uint256 public cliff;
  mapping (address => uint256) public released;

  function vestedAmount(uint32 _token) public view returns (uint256) {
    uint256 totalBalance = 100 + released[_token];

    if (100 < cliff) {
      return totalBalance * block.timestamp;
    }
  }
}

1
----------------------------------------

00 1181.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract AqwireToken {
    uint256 public unlockTime;

    function transfer() public returns (bool) {
        require(block.timestamp >= unlockTime);
        return true;
    }
}

0
----------------------------------------

00 1182.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BitSongCrowdsale {
    address public owner;
    uint256 public openingTime;
    uint256 public closingTime;
    uint256 public duration;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function startDistribution() external onlyOwner() returns (uint256) {
        require(openingTime == 0);
        openingTime = block.timestamp;
        closingTime = openingTime + duration;
        return closingTime;
    }
}

1
----------------------------------------

00 1183.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BitSongCrowdsale {
    uint256 public openingTime;
    uint256 public closingTime;
    uint256 public duration;

    function startDistribution() external returns (uint256) {
        openingTime = block.timestamp;
        closingTime = openingTime + duration;
        return closingTime;
    }
}

1
----------------------------------------

00 1226.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FreezableCoin {

    struct FreezingNode {
        uint end_stamp;
        uint num_coins;
    }
    mapping(address => FreezingNode[]) internal c_freezing_list;
    uint total_coins;

    function validBalanceOf(address addr) constant public returns (uint) {
        FreezingNode[] memory nodes = c_freezing_list[addr];


        for (uint i = 0; i < nodes.length; ++i) {
            if (nodes[i].end_stamp > block.timestamp) {
                total_coins = total_coins - nodes[i].end_stamp;
                return total_coins ;
            }
        }
    }
}

1
----------------------------------------

00 1246.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimedCrowdsale {
    uint openingTime = 0;

    function TimedCrowdsal(uint256 _openingTime) public returns (bool) {
        require(_openingTime >= block.timestamp);
        openingTime = _openingTime;
        return true;
    }
}

0
----------------------------------------

00 1256.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Betting {
    struct chronus_info {
        uint32  starting_time;
        uint32  betting_duration;
        uint32  race_duration;  
    }
    chronus_info public chronus;
    address public owner;
     
    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }
    function setupRace(uint32 _bettingDuration, uint32 _raceDuration) onlyOwner external payable returns (uint32) {
        chronus.starting_time = uint32(block.timestamp);
        chronus.betting_duration = _bettingDuration;
        chronus.race_duration = _raceDuration;
        return chronus.starting_time;
    }
}

1
----------------------------------------

00 1284.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SafeMath1 {
    function time() public constant returns (uint256) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 1288.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Ownable1 {
  uint public startsAt;
  enum State { PreFunding, Funding}

  function getState() public constant returns (State) {
    if (block.timestamp < startsAt) {
        return State.PreFunding;
    } else {
        return State.Funding;
    }
  }
}

1
----------------------------------------

00 1313.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenTimelock {
  uint256 public token;
  uint256 public releaseTime;

  function release() public returns (uint256){
    require(block.timestamp >= releaseTime);
    uint256 amount = token * 2;
    require(amount > 0);
    return amount;
  }
}


0
----------------------------------------

00 1318.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract WorkIt {
  uint public startDate;
  uint secondsPerDay = 86400;

  address public owner;
  modifier onlyOwner() {
        require(msg.sender == owner);
        _;
  }

  function currentDay() public view onlyOwner() returns (uint) {
    return (block.timestamp - startDate) / secondsPerDay;
  }
}

1
----------------------------------------

00 1319.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract WorkIt {
  uint public startDate;
  uint secondsPerDay = 86400;

  function currentDay() public view returns (uint) {
    return (block.timestamp - startDate) / secondsPerDay;
  }
}

1
----------------------------------------

00 1404.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CryptualProjectToken {
  uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];
  uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];

  function getCrowdsaleUserCap() public view returns (uint256) {
    uint256 elapsedTime = block.timestamp + (1534935600);
    uint256 currentCap = 0;

    for (uint i = 0; i < crowdsaleUserCaps.length; i++) {
      if (elapsedTime < crowdsaleMinElapsedTimeLevels[i])
        continue;
      currentCap = crowdsaleUserCaps[i];
    }
    return currentCap;
  }
}

1
----------------------------------------

00 1445.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ERC20Basic {
  function balanceOf(address who) public view returns (uint256);
}

contract TokenVesting {

  ERC20Basic public token;

  uint256 public start;
  uint256 public currentBalance;
  mapping (address => uint256) public released;
  uint256 public totalBalance;

  function vestedAmount() public returns (uint256) {
    currentBalance = token.balanceOf(this);
    totalBalance = currentBalance + (released[token]);

    if (block.timestamp >= start) {
        return totalBalance;
    }
  }
}

1
----------------------------------------

00 1532.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract AdditionalToken {
    address public owner;
    uint256 public maxProportion;
    uint256 public totalSupply;
    mapping(uint256 => uint256) public maxAmountPer;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function mint(address _to, uint256 _amount) onlyOwner public returns (bool) {
        uint256 curTime = block.timestamp;
        uint256 curTimes = curTime / (31536000);

        if(maxAmountPer[curTimes] == 0) {
            maxAmountPer[curTimes] = totalSupply * (maxProportion) / (100);
        }

        return true;
    }
}


1
----------------------------------------

00 1533.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract AdditionalToken {
    uint256 public maxProportion;
    uint256 public totalSupply;

    mapping(uint256 => uint256) public maxAmountPer;

    function mint(address _to, uint256 _amount) public returns (bool) {
        uint256 curTime = block.timestamp;
        uint256 curTimes = curTime / (31536000);

        if(maxAmountPer[curTimes] == 0) {
            maxAmountPer[curTimes] = totalSupply * (maxProportion) / (100);
        }
        return true;
    }
}


1
----------------------------------------

00 1631.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenLock {
    mapping (address => bool) owners;
    mapping (address => uint256) public lockAmounts;
    mapping (address => uint256) public releaseTimestamps;

    function release(address _addr) external returns (bool){
        require(block.timestamp >= releaseTimestamps[_addr]);
        lockAmounts[_addr] = 0;
        releaseTimestamps[_addr] = 0;
        return true;
    }
}

0
----------------------------------------

00 1667.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JobsBounty {
    address public owner;
    uint public endDate = 0;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdrawERC20Token() external onlyOwner returns(bool){
        assert(block.timestamp >= endDate);
        return true;
    }
}

0
----------------------------------------

00 1668.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JobsBounty {
    uint public endDate = 0;

    function withdrawERC20Token() external returns(bool){
        assert(block.timestamp >= endDate);
        return true;
    }
}

0
----------------------------------------

00 1813.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Bittwatt {
    function createDate(uint _minutes, uint _seconds) public view returns (uint) {
        uint currentTimestamp = block.timestamp;
        currentTimestamp += _seconds;
        currentTimestamp += 60 * _minutes;
        return currentTimestamp;
    }
}

1
----------------------------------------

00 1824.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Zmbc {

    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;
    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner returns (uint256) {
        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);
        return newBuyPrice - newSellPrice;
    }
}

0
----------------------------------------

00 1825.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Zmbc {

    uint public PRICE_CHANGE_ENDING_TIME = 1533364469;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) returns (uint256) {
        require(block.timestamp <= PRICE_CHANGE_ENDING_TIME);
        return newBuyPrice - newSellPrice;
    }
}

0
----------------------------------------

00 1851.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract secondContract {

    uint timeWindow = 18;

    function BirthdayBoyClickHere() public view returns(string) {
        uint time = block.timestamp;
        require(time < timeWindow);
        return "Happy Birthday";
    }
}

0
----------------------------------------

00 1954.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ERC20Basic {
  function balanceOf(address who) public view returns (uint256);
}
 
contract ANBXTimelock {

  ERC20Basic public token;
  uint256 public secondReleaseTime;
  uint256 amount;

  function release() public returns (bool) {

    if (block.timestamp >= secondReleaseTime) {
      amount = token.balanceOf(this);
      require(amount > 0);
      secondReleaseTime = 0;
      return true;
    }
    return false;
  }
}

1
----------------------------------------

00 2051.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EcroContract {
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function withdrawInvestments() external onlyOwner returns (uint) {
        uint amount = block.timestamp;
        return amount;
    }
}

1
----------------------------------------

00 2252.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CardsRaffle {
  uint256 private raffleTicketsBought;
  uint256 private raffleTicketThatWon;
  address public owner;

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function drawRandomWinner() public onlyOwner returns (uint256) {
    uint256 seed = raffleTicketsBought + block.timestamp;
    raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);
    return raffleTicketThatWon;
  }
}

1
----------------------------------------

00 2253.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CardsRaffle {
  uint256 private raffleTicketsBought;
  uint256 private raffleTicketThatWon;

  function drawRandomWinner() public returns (uint256) {
    uint256 seed = raffleTicketsBought + block.timestamp;
    raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, raffleTicketsBought);
    return raffleTicketThatWon;
  }
}

1
----------------------------------------

00 2379.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FoMoJP {
    uint256 public airDropTracker_ = 0;

    function airdrop() private view returns(bool) {
        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) / now )));
        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)
            return true;
        else
            return false;
    }
}

1
----------------------------------------

00 2397.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MEWCrowdsale {
    uint256[2] internal signatures;
    address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);

    function changeWallet(address newWallet) public returns (bool) {
        uint256 blocktime = block.timestamp;

        if (msg.sender == SIGN_ADDRESS1) {
            signatures[0] = blocktime;
        }
        return true;
    }
}

1
----------------------------------------

00 2399.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BasicToken {

  mapping(address => uint256) public mVestingDays;   
  mapping(address => uint256) public mVestingBegins;

  function ComputeVestSpend(address target) public returns (uint256) {
      int256 vestingDays = int256(mVestingDays[target]);
      int256 vestingProgress = (int256(block.timestamp) - int256(mVestingBegins[target])) / (int256(24*60*60));

      if (vestingProgress > vestingDays) {
          vestingProgress = vestingDays;
      }

      return 0;
  }
}

1
----------------------------------------

00 2563.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MyPurchaseContract {
  uint256 public startAt;
  uint256 public stopAt;
  uint256 public grantAt;

  function MyPurchaseContrat() public returns (uint256) {
     startAt = block.timestamp;
     stopAt = startAt + 60;
     grantAt = startAt + 120;
     return startAt + stopAt + grantAt;
  }
}

1
----------------------------------------

00 2688.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract F3d {
  mapping(uint256 => Round) public rounds;
  uint256 public currentRound;
  struct Round {
      uint256 endTime;      
  }

  function remainTime() public view returns (uint256) {
      uint time = block.timestamp;
      if (rounds[currentRound].endTime <= time) {
          return 0;
      } else {
          return rounds[currentRound].endTime - time;
      }
  }
}

1
----------------------------------------

00 2777.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FoMo3DWorld {
    uint256 public airDropTracker_ = 0;      

    function airdrop() private view returns(bool) {
        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));
        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)
            return(true);
        else
            return(false);
    }
}

1
----------------------------------------

00 3185.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract StarmidFreezeTokens {

	function refundTokens(address _to, uint _amount) public returns(bool) {
        require(block.timestamp > 1601510400);
        return true;
    }
}

0
----------------------------------------

00 3434.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Greedy {
    uint256 public luckybuyTracker_ = 0;

    function luckyBuy() private view returns(bool) {
        uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp) + (block.difficulty))));
        if((seed - ((seed / 1000) * 1000)) < luckybuyTracker_)
            return(true);
        else
            return(false);
    }
}

1
----------------------------------------

00 3543.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract OutCloud {
    uint256 public preico_startdate;
    uint public bonusCalculationFactor;
    uint disc;

    function getCurrentTokenPricepreICO() private returns (uint) {
        bonusCalculationFactor = (block.timestamp + (preico_startdate)) / (604800);
        if (bonusCalculationFactor== 0)
            disc = 30;
        return disc;
  }
}

1
----------------------------------------

00 3554.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Redenom {
    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function pay055loyal(address to) public onlyOwner returns(bool success){
        uint new_amount = 55566600 + (block.timestamp % 100);
        return true;
    }
}  

0
----------------------------------------

00 3555.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract Redenom {

    function pay055loyal(address to) public returns(bool success){
        uint new_amount = 55566600 + (block.timestamp % 100);
        return true;
    }
}  

0
----------------------------------------

00 3654.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenSale {
    uint public tokenPrice;
    uint public deadline;

    function buyTokens() payable {
        require(block.timestamp < deadline && tokenPrice > 0);
    }
}

1
----------------------------------------

00 3702.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TMTGBaseToken {
    uint256 public openingTime;
    struct investor {
        uint256 _limit;
    }
    mapping(address => investor) public searchInvestor;

    function _timelimitCal() internal view returns (uint256) {
        uint256 presentTime = block.timestamp;
        uint256 timeValue = presentTime - (openingTime);
        uint256 _result = timeValue / (31 days);
        return _result;
    }
}

1
----------------------------------------

00 3729.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Basic {
    uint256 public openingTime;

    function getLimitPeriod() external view returns (uint256) {
        uint256 presentTime = block.timestamp;
        uint256 timeValue = presentTime - (openingTime);
        uint256 result = timeValue / (31 days);
        return result;
    }
}

1
----------------------------------------

00 3772.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SparksterToken {

	struct Group {
		uint256 startTime;
	}

	mapping(uint256 => Group) internal groups;
	uint256 public openGroupNumber;

	function purchase() public  payable returns(bool success) {
		Group storage openGroup = groups[openGroupNumber];
		uint256 currentTimestamp = block.timestamp;
		require(currentTimestamp >= openGroup.startTime);
	}
}

0
----------------------------------------

00 3952.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseFutures {

    mapping(bytes32 => address) owner;

    function sellOffer(uint256 amount, uint256 price, address race, bytes32 horse) external returns (bytes32) {
        bytes32 id = keccak256(abi.encodePacked(amount,price,race,horse,true,block.timestamp));
        require(owner[id] == address(0));
        return id;
    }

}

0
----------------------------------------

00 4225.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DSNote {

    function time() public constant returns (uint) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 4467.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TydoIco {
  uint256[] public bonuses;
  uint256[] public bonusEnds;

  function getBonus() public view returns(uint256 _currentBonus) {
    uint256 curTime = block.timestamp;
    for(uint8 i = 0; i < bonuses.length; i++) {
      if(bonusEnds[i] > curTime) {
        return bonuses[i];
      }
    }
    return 0;
  }
}

1
----------------------------------------

00 4474.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimedCrowdsale  {
  uint256 public closingTime;

  function hasClosed() public view returns (bool) {
    return block.timestamp > closingTime;
  }
}

1
----------------------------------------

00 4523.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MMOToken {
    mapping (address => uint256) public lockAddress;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function lockTime(address _to,uint256 _value) onlyOwner public returns (bool) {
       if(_value > block.timestamp) {
            lockAddress[_to] = _value;
            return true;
       }
       return false;
    }
}

1
----------------------------------------

00 4524.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MMOToken {
    mapping (address => uint256) public lockAddress;

    function lockTime(address _to,uint256 _value) public returns (bool) {
       if(_value > block.timestamp) {
            lockAddress[_to] = _value;
            return true;
       }
       return false;
    }
}

1
----------------------------------------

00 4587.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TMTG {
    uint256 public openingTime;

    function setOpeningTime() public returns (bool) {
        openingTime = block.timestamp;
        return true;
    }
}

0
----------------------------------------

00 4588.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TMTG {
    uint256 public openingTime;

    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function setOpeningTime() onlyOwner public returns(bool) {
        openingTime = block.timestamp;
        return false;
    }
}

0
----------------------------------------

00 4590.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GameTestToken {
  mapping(address => TimeLock[]) public allocations;
  
  struct TimeLock {
      uint time;
      uint256 balance;
  }

  function subAllocation(address sender) private returns(bool){
      for (uint j = 0; j < allocations[sender].length; j++) {
          if (allocations[sender][j].time < block.timestamp) {
                allocations[sender][j].balance = 0;
                return true;
          }
      }
      return false;
  }
}

1
----------------------------------------

00 4717.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract TokenTimelock {

  uint256 public releaseTime;

  function release() public returns (bool) {
    require(block.timestamp >= releaseTime);
    return true;
  }
}


0
----------------------------------------

00 4882.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract ERC20 {
  function balanceOf(address to) public returns (uint256);
}

contract TokenLocker {
    
    ERC20 public token = ERC20(0x611171923b84185e9328827CFAaE6630481eCc7a);
    uint256 public releaseTimeFund = 1537833600;  
    uint public ReserveFundAmount = 18600000 ether;
    
    function unlockFund () public returns (bool){
        require(releaseTimeFund <= block.timestamp);
        require(ReserveFundAmount > 0);
        uint tokenBalance = token.balanceOf(this);
        require(tokenBalance >= ReserveFundAmount);
        return false;
    }
}

0
----------------------------------------

00 4922.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Eurufly {
      uint256 public prePreIcoStartAt;
      address public owner;

      modifier onlyOwner() {
        require(msg.sender == owner);
        _;
      }

    enum STATE{ PREPREICO }

    STATE public state;

    function startPrePreIco() public onlyOwner returns (STATE) {
        prePreIcoStartAt = block.timestamp;
        state = STATE.PREPREICO;
        return state;
    }
}

0
----------------------------------------

00 4926.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenTimelockVault {
    mapping(address => TimeEnvoy) internal owners;

    struct TimeEnvoy {
        uint releaseTime;
        uint balance;
    }

    function releasableAmount(address _owner) public view returns (uint256){
        TimeEnvoy storage owner = owners[_owner];
        if (block.timestamp >= owner.releaseTime) {
            return owner.balance;
        }
    }
}

1
----------------------------------------

00 4993.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract Crowdsale {

    uint256 public bonusDeliverTime;
    uint256 public bonusUnsold;

    function returnBonus() external returns (uint) {
        require(block.timestamp > bonusDeliverTime);
        require(bonusUnsold > 0);
        return bonusUnsold;
    }

}

0
----------------------------------------

00 5132.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract COD {

    mapping(address => uint) balances;

    function burn (uint256 _burntAmount) public returns (bool success) {
    	require(balances[msg.sender] >= _burntAmount && block.timestamp > 10);
    	return true;
	}
}

0
----------------------------------------

00 5142.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract TokenTimelock {

    uint256 public cliffPeriod;
    uint256 public chunksAlreadyVested;

   function release() public returns (uint256){
    uint256 chunksNeeded = (block.timestamp - (cliffPeriod));
    if (chunksNeeded > 10) {
        chunksNeeded = 10;
    }
    chunksAlreadyVested = chunksNeeded;
    return chunksAlreadyVested;
  }
}

1
----------------------------------------

00 5143.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ParkadeCoinCrowdsale {
  uint256 public firstBonusRate = 1838;
  uint256 public normalRate = 1470;
  uint256 public firstBonusEnds = 1535155200;

  function currentRate() public view returns (uint256) {
    if (block.timestamp < firstBonusEnds) {
        return firstBonusRate;
    }
    else {
         return normalRate;
    }
  }
}

1
----------------------------------------

00 5164.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Lock {

    mapping(address => uint256) public teamLockTime;

    function teamAvailable(address _to) internal constant returns (uint256) {

        uint256 now1 = block.timestamp;
        uint256 lockTime = teamLockTime[_to];
        uint256 time = now1 - (lockTime);
        uint256 percent = 0;

        if(time >= 365 days) {
           percent = (time / (30 days)) + (1);
        }

        uint256 avail = avail * (percent) / (12) ;
        return avail;
    }
}

1
----------------------------------------

00 5259.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DSEasyMultisig {

    struct action {
        uint confirmations;  
        uint expiration;  
    }
    mapping( uint => action ) actions;

    function trigger(uint action_id) returns (bool){
        var a = actions[action_id];
        if(block.timestamp > a.expiration) { throw; }
        return true;
    }
}

0
----------------------------------------

00 5339.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract game {

    mapping (address => uint) readyTime;

    function view_readyTime(address _address) view public returns(uint _readyTime){
        uint time = block.timestamp;

        if (time >= readyTime[_address]){
            return 0 ;
        }
        else{
            return readyTime[_address] - time ;
        }
    }
}

1
----------------------------------------

00 5934.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FreyrTokenLocker {

    uint256 public releaseTime;

    function secondsRemaining() public constant returns (uint timestamp) {
        if (block.timestamp < releaseTime)
            return releaseTime;
        else
            return 0;
    }
}

1
----------------------------------------

00 5975.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProVisionRaffle {
    address[] public Raffle_Entries;

    function random() private view returns (uint8) {
        return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty))) % Raffle_Entries.length);
    }
}

1
----------------------------------------

00 6149.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JadeCoin {

  uint256 public nextSnapshotTime;

  function snapshotDailyGooResearchFunding() external returns (bool){
    nextSnapshotTime = block.timestamp + 24 hours;
    return true;
  }
}

0
----------------------------------------

00 6199.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BulletinBoard {
    struct Message {
        address sender;
        string text;
        uint timestamp;
        uint amount;
    }

    Message[] public messages;
    function addMessage(string text) public payable returns (bool) {
        messages.push(Message(msg.sender, text, block.timestamp, msg.value));
        return true;
    }
}

0
----------------------------------------

00 6220.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MINEA {

    uint private randomNumber;
    mapping (address => uint256) public successesOf;

    function () external payable {
        randomNumber += block.timestamp;
        uint minedAtBlock = uint(block.blockhash(block.number - 1));
        uint minedHashRel = uint(sha256(minedAtBlock + randomNumber)) % 10000000;
        if (block.timestamp < minedHashRel) {
            successesOf[msg.sender]++;
        }
    }
}

1
----------------------------------------

00 6272.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JadeCoin {
  mapping(address => uint256) public jadeBalance;
  mapping(address => uint256) public lastJadeSaveTime;  

  function updatePlayersCoinByOut(address player) external returns (bool){
    lastJadeSaveTime[player] = block.timestamp;
    jadeBalance[player] = jadeBalance[player] + 100;
    return true;
  }
}

0
----------------------------------------

00 6348.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DutchAuction {
	event BidSubmission(
        address indexed sender,
        uint amount,
        uint missingFunds,
        uint timestamp
    );

    function bid() public payable returns (bool){
        uint missingFunds = 100;
        BidSubmission(msg.sender, msg.value, missingFunds, block.timestamp);
        return true;
    }
}

0
----------------------------------------

00 6369.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LemoCoin {
    struct FreezingNode {
        uint end_stamp;
    }
    mapping(address => FreezingNode[]) internal c_freezing_list;
    uint total_lemos = 100;

    function validBalanceOf(address addr) constant public returns (uint) {
        FreezingNode[] memory nodes = c_freezing_list[addr];
        for (uint i = 0; i < nodes.length; ++i) {
            if (nodes[i].end_stamp > block.timestamp) {
                total_lemos = total_lemos - nodes[i].end_stamp;
            }
        }
        return total_lemos;
    }
}

1
----------------------------------------

00 6534.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract XTVToken {
  uint public endTime;
  uint public XTVBurned;
  mapping(address => uint256) balances;

  function burnTokens() public returns (uint){
    require(block.timestamp > endTime);
    uint256 remaining = balances[address(0)];
    XTVBurned = remaining;
    return XTVBurned;
  }
}

0
----------------------------------------

00 6578.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CryptualProjectToken {
  uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600];
  uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, 5000 ether];
  uint256 currentCap = 0;

  function getCrowdsaleUserCap() public view returns (uint256) {
    uint256 elapsedTime = block.timestamp - (100);

    for (uint i = 0; i < crowdsaleUserCaps.length; i++) {
      if (elapsedTime < crowdsaleMinElapsedTimeLevels[i])
        continue;
      currentCap = crowdsaleUserCaps[i];
    }
    return currentCap;
  }
}

1
----------------------------------------

00 6929.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PitEur {
  mapping(address => uint256) releaseTimes;

  function isLocked(address _spender) public view returns (bool) {
    if (releaseTimes[_spender] <= block.timestamp) {
        return false;
    }
    return true;
  }
}

1
----------------------------------------

00 7134.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FENIX {
    uint256 public ico_startdate;
    uint bonusCalculationFactor;
    uint price_tokn;

    function getCurrentTokenPrice() private returns (uint) {

        bonusCalculationFactor = (block.timestamp - (ico_startdate)) / (3600);

        if (bonusCalculationFactor== 0) 
            price_tokn = 70;
            return price_tokn;
     }
}

1
----------------------------------------

00 7330.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract KcashVesting {
    uint256 public lockStartTime;

    mapping(address => uint256) public stageSettings;
    mapping(address => uint256) public timeLockDurations;

    function vestStage() public view returns(uint256){
        uint256 vestingMonths = 100;
        uint256 stage = (block.timestamp - (lockStartTime)) / (vestingMonths);
        if(stage > stageSettings[msg.sender]){
            stage = stageSettings[msg.sender];
        }
        return stage;
    }
}

1
----------------------------------------

00 7419.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SponsoredItemGooRaffle {
    uint256 private raffleTicketsBought;
    uint256 private raffleTicketThatWon;

    function drawRandomWinner() public returns (uint256) {
        uint256 seed = raffleTicketsBought + block.timestamp;
        raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, (raffleTicketsBought + 1));
        return raffleTicketThatWon;
    }
}

1
----------------------------------------

00 7570.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GStarCrowdsale {
    uint256 constant public startTime = 1532260800;
    uint256 rate = 100;

    function getRate() public view returns (uint256) {
        if (block.timestamp <= startTime) {
            return ((rate / 100) * 120);
        }
        return rate;
    }
}

1
----------------------------------------

00 7593.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EtheremonEnergy {
    
    struct Energy {
        uint lastClaim;
    }
    
    mapping(address => Energy) energyData;
    uint public claimTime = 30 * 60;
    uint public claimAmount = 1;

    function getClaimableAmount(address _trainer) constant external returns(uint) {
        Energy storage energy = energyData[_trainer];
        uint period = block.timestamp + energy.lastClaim;
        uint energyAmount = (period / claimTime) * claimAmount;
        if (energyAmount > claimAmount)
            energyAmount = claimAmount;
        return energyAmount;
    }
}

1
----------------------------------------

00 8025.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ESSENTIA_PE {
    uint256 public pubEnd = 0;
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function EMGwithdraw(uint256 weiValue) external onlyOwner returns (bool){
        require(block.timestamp > pubEnd);           
        require(weiValue > 0);
        return true;
    }
}

0
----------------------------------------

00 8026.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ESSENTIA_PE {
    uint256 public pubEnd = 0;

    function EMGwithdraw(uint256 weiValue) external returns (bool){
        require(block.timestamp > pubEnd);           
        require(weiValue > 0);
        return true;
    }
}

0
----------------------------------------

00 8099.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract tipbot {
    struct transferInStruct{
        uint256 amount;
        uint64 time;
    }

    mapping(address => uint256) balances;
    mapping(address => transferInStruct[]) transferIns;

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        uint64 _now = uint64(block.timestamp);
        transferIns[_from].push(transferInStruct(uint256(balances[_from]),_now));
        transferIns[_to].push(transferInStruct(uint256(_value),_now));
        return true;
    }
}

1
----------------------------------------

00 8141.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Inner4WithEth {
    uint256 someValue;

    function doSomething() public payable {
        someValue = block.timestamp;
    }
}

0
----------------------------------------

00 8342.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CHAltar {
  uint256 public genesis;

  function _getCurrentAltarRecordId() internal view returns (uint256) {
    return (block.timestamp - genesis) / 86400;
  }
}

1
----------------------------------------

00 8606.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract YunMint {
    uint    public cycleCount = 0;
    uint256 public firstReleaseAmount;
    uint256 public createTime = 0;

    function YunMin(address _operator) public returns(uint256){
        createTime = block.timestamp;
        cycleCount = createTime;
        firstReleaseAmount = 200000 * (10 ** 8);
        return firstReleaseAmount + cycleCount;
    }
}

1
----------------------------------------

00 8826.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenOffering {

    uint256 public startTime;
    uint256 public endTime;

    function updateStartTime(uint256 _startTime) public {
        require(_startTime <= endTime);
        require(_startTime >= block.timestamp);
    }
}

0
----------------------------------------

00 9208.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {
  uint public startsAt;

  function getCurrentFgcCap() public constant returns (uint) {
    uint timeSinceStart = block.timestamp - (startsAt);
    uint currentPeriod = timeSinceStart / (1 days) + (1);

    if (currentPeriod < 2) {
        return 5000 * 10** currentPeriod;
    }
    return 0;
  }
}

1
----------------------------------------

00 9230.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Tokenlock {
    uint256 public interval;
    uint256 public releaseTime;

    function start() external returns (uint256){
        uint time = block.timestamp;
        releaseTime = time + interval;
        return releaseTime;
    }
}

1
----------------------------------------

00 9377.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PGOMonthlyInternalVault {

    uint256 public cliff;
    uint256 vested = 0;

    function vestedAmount() public view returns (uint256) {

        uint256 timme = block.timestamp;
        if (timme >= cliff) {
            uint256 time = timme - (cliff);
            uint256 elapsedOffsets = time / (21);
            vested = vested + (elapsedOffsets);
        }
        return vested;
    }
}

1
----------------------------------------

00 9379.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Ownable1 {
    function started() public view returns(bool) {
        if (block.timestamp >= 100) {
            return true;
        } else {
            return false;
        }
    }
}

1
----------------------------------------

00 9428.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DiceRoll {

    uint64 nextJackpotTime;

    function createWinner() public {
        uint64 tmNow = uint64(block.timestamp);
        require(tmNow >= nextJackpotTime);
    }
}

0
----------------------------------------

00 9560.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract dappVolumeAd {
	uint256 public purchaseTimestamp;

	function updateAd() public payable {
		purchaseTimestamp = block.timestamp;
		require(purchaseTimestamp > 10);
	}
}

0
----------------------------------------

00 9654.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SimpleBet {
	function random() view returns (uint8) {
        return uint8(uint256(keccak256(block.timestamp, block.difficulty)) % 256);
    }
}

1
----------------------------------------

00 9820.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CrowdsaleRC {
    uint public createdTimestamp;

    function CrowdsaleRC () public {
        createdTimestamp = block.timestamp;
    }
}

0
----------------------------------------

00 9850.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PLCRVoting {

    function startPoll(uint _commitDuration, uint _revealDuration) public returns (uint) {
        uint commitEndDate = block.timestamp + (_commitDuration);
        uint revealEndDate = commitEndDate + (_revealDuration);
        return revealEndDate;
    }
}

1
----------------------------------------

00 9918.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DSNote {
    function time() constant returns (uint) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 10146.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract KOIOSTokenSale {
	uint256 public startingTimestamp = 1518696000;
	uint256 public endingTimestamp = 1521115200;

	function isValidPurchase(uint256 value, uint256 amount) internal constant returns (bool) {
		bool validTimestamp = startingTimestamp <= block.timestamp && endingTimestamp >= block.timestamp;
		return validTimestamp;
	}
}

1
----------------------------------------

00 10233.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EthTeamContract {
    uint64 public finishTime;
    address public feeOwner;

    function finish() public {
        require(block.timestamp >= finishTime);
        feeOwner.transfer(address(this).balance);
    }
}

0
----------------------------------------

00 10295.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ERC20Like {
    mapping(address => Account) internal accounts;
      struct DirectDebitInfo {
        uint256 amount;
        uint256 startTime;
        uint256 interval;
      }

      struct DirectDebit {
        DirectDebitInfo info;
        uint256 epoch;
      }

      struct Instrument {
        uint256 allowance;
        DirectDebit directDebit;
      }

      struct Account {
        uint256 balance;
        uint256 nonce;
        mapping (address => Instrument) instruments;
      }

    function withdrawDirectDebit(address debtor) public returns (uint) {
        Account storage debtorAccount = accounts[debtor];
        DirectDebit storage debit = debtorAccount.instruments[msg.sender].directDebit;
        uint256 epoch = (block.timestamp - (debit.info.startTime) / debit.info.interval) + (1);
        uint256 amount = epoch - (debit.epoch) * (debit.info.amount);
        return amount;
    }
}

1
----------------------------------------

00 10342.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DAVToken {
  bool public paused = false;
  uint256 public pauseCutoffTime;

  function pause() public returns(bool) {
        require(pauseCutoffTime >= block.timestamp);
        paused = true;
        return paused;
  }
}

0
----------------------------------------

00 10369.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MuskTokenVault {
    uint256 public teamTimeLock = 2 * 365 days;
    uint256 public teamVestingStages = 8;
    uint256 public lockedAt = 0;

    function teamVestingStage() public view returns(uint256){
        uint256 vestingMonths = teamTimeLock / (teamVestingStages);
        uint256 stage = (block.timestamp - (lockedAt)) / (vestingMonths);
        if(stage > teamVestingStages){
            stage = teamVestingStages;
        }
        return stage;
    }
}

1
----------------------------------------

00 10547.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ATTRToken  {
    uint256 public releaseTime = uint256(1536278399);

    function setReleaseTime(uint256 _time) public returns (bool){
        require(_time > block.timestamp);
        releaseTime = _time;
        return true;
    }
}

0
----------------------------------------

00 10736.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LescovexERC20 {
    mapping (address => timeHold) holded;
    struct timeHold {
        uint256[] time;
        uint256 length;
    }

    uint256 public holdTime;
    function holdedOf(address _owner) public view returns (uint256) {
        uint256 requiredTime = block.timestamp - holdTime;
        uint256 iValid = 0;                          
        uint256 iNotValid = holded[_owner].length;
        if (holded[_owner].time[iValid] >= requiredTime) {
            return 0;
        }

    }
 }

1
----------------------------------------

00 10855.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenLock {
    mapping (uint256 => TokenTimeLockInfo) public locks;

    struct TokenTimeLockInfo {
        uint256 unlockTime;
    }

    function unlock (uint256 _id) public {
        TokenTimeLockInfo memory lockInfo = locks[_id];
        require (lockInfo.unlockTime <= block.timestamp);
    }
}

0
----------------------------------------

00 11064.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ANSAToken {
   uint256 public tradeStartTime;

   function hasTrade() public view returns (bool) {
      return block.timestamp > tradeStartTime;
   }
}

1
----------------------------------------

00 11159.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract KuaiMintableToken {
    uint256 public lastMintTime = 0;
    uint256 public createTime;

    function KuaiMintableToken() public {
        createTime = block.timestamp;
        lastMintTime = createTime;
        return;
    }
}

0
----------------------------------------

00 11243.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BasicAccessControl {

    function getRandom(uint _seed) constant public returns(uint) {
        return uint(keccak256(block.timestamp, block.difficulty)) ^ _seed;
    }
}

1
----------------------------------------

00 11323.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TUINETWORK {

    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1559347200;

    function inAllocationLockPeriod() constant returns (bool) {
        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);
    }
}

0
----------------------------------------

00 11330.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BWData {
    mapping (address => User) private users;
     
    struct User {
        uint creationTime;
    }

    function addUser(address _msgSender) public  {
        User storage user = users[_msgSender];
        user.creationTime = block.timestamp;
        require(user.creationTime == 0);
        return;
    }
}

0
----------------------------------------

00 11346.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SmartVows {
    Event[] public lifeEvents;

    struct Event {
        uint date;
        string name;
        string description;
        string mesg;
    }

    function saveLifeEvent(string name, string description, string mesg) private {
        lifeEvents.push(Event(block.timestamp, name, description, mesg));
        return;
    }
}

0
----------------------------------------

00 11457.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BCVTokenVault {
    mapping(address => uint256) public timeLocks;
    mapping(address => uint256) public claimed;

    function canCollect() public view returns(bool) {
        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;
    }
}

1
----------------------------------------

00 11798.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CopaDelCrypto {
  address public owner;
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  uint256 public prizeValue;
  uint256 public resultsPublishedTime;
  address[] public players;

  function CancelGame() public onlyOwner {
    resultsPublishedTime = block.timestamp;
    prizeValue = address(this).balance / players.length;
    return;
  }
}

0
----------------------------------------

00 11931.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Fluzcoin {
    uint public launched = 0;  

    function launch() public returns(uint){
        launched = block.timestamp;
        return launched;
    }
}

1
----------------------------------------

00 11964.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ERC20Basic {
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
}

contract TokenTimelock {
  ERC20Basic public token;
  uint256 public releaseTime;

  function release() public {
    require(block.timestamp >= releaseTime);
    uint256 amount = token.balanceOf(this);
    require(amount > 0);
    return;
  }
}

0
----------------------------------------

00 12044.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ESS {
    address public token;
    mapping (address => uint256) public sold;
    uint256 public pubEnd = 0;

    function withdrawPUB() public returns(bool){
        require(block.timestamp > pubEnd);
        bool result = token.call(bytes4(keccak256("transfer(address,uint256)")), msg.sender, sold[msg.sender]);
        return result;
    }
}

0
----------------------------------------

00 12115.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LocalEthereumEscrows {

    function createEscrow(uint32 _expiry) payable external {
        require(block.timestamp < _expiry, "Signature has expired");
        return;
    }
}

0
----------------------------------------

00 12292.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UniDAGCrowdsale {
    uint256 public rateFirstRound = 4000;
	uint256 public secondRoundTime = 1539129600;

    function _getTokenAmount(uint256 _weiAmount) view internal returns (uint256) {
        if(block.timestamp < secondRoundTime)
            return _weiAmount * (rateFirstRound);
    }
}

1
----------------------------------------

00 12321.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProgressiveIndividualCappedCrowdsale {
    uint public startGeneralSale;
    uint public constant TIME_PERIOD_IN_SEC = 1 days;
    uint256 public baseEthCapPerAddress;

    function getCurrentEthCapPerAddress() public constant returns(uint) {
        uint time = block.timestamp;
        uint timeSinceStartInSec = time - (startGeneralSale);
        uint currentPeriod = timeSinceStartInSec / (TIME_PERIOD_IN_SEC) + (1);
        return 2 ** currentPeriod;
    }
}


1
----------------------------------------

00 12393.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Distribution {
  uint256 public stageDuration;
  uint256 public startTime;

  function getStage() public view returns(uint16) {
    return uint16(uint256(block.timestamp) - (startTime) / (stageDuration));
  }
}

1
----------------------------------------

00 12460.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {

  function buyTokens() public payable {
    uint shipAmount = block.timestamp;
    require(shipAmount > 0);
    return;
  }
}

0
----------------------------------------

00 12465.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ShareXTokenVault {
    mapping(address => uint256) public timeLocks;
    mapping(address => uint256) public claimed;

    function canCollect() public view returns(bool) {
        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;
    }
}

1
----------------------------------------

00 12466.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ShareXTokenVault {

    mapping(address => uint256) public allocations;
    mapping(address => uint256) public timeLocks;
    mapping(address => uint256) public claimed;
     
    modifier onlyOwner {
        require(allocations[msg.sender] > 0);
        _;
    }

    function canCollect() public view onlyOwner returns(bool) {
        return block.timestamp > timeLocks[msg.sender] && claimed[msg.sender] == 0;
    }
}

1
----------------------------------------

00 12688.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DAVToken {

  uint256 public pauseCutoffTime;
  address public owner;

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function setPauseCutoffTime(uint256 _pauseCutoffTime) onlyOwner public {
    require(_pauseCutoffTime >= block.timestamp);
    pauseCutoffTime = _pauseCutoffTime;
    return;
  }
}

0
----------------------------------------

00 12689.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DAVToken {

  uint256 public pauseCutoffTime;

  function setPauseCutoffTime(uint256 _pauseCutoffTime)  public {
    require(_pauseCutoffTime >= block.timestamp);
    pauseCutoffTime = _pauseCutoffTime;
    return;
  }
}

0
----------------------------------------

00 12715.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract NokuFlatPlan {

    uint256 public nextPaymentTime;
     
    function payFee() public returns(bool paid) {
        require(block.timestamp < nextPaymentTime);
        return true;
    }
}

0
----------------------------------------

00 12841.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Lottery {
    uint inactivity = 1;

    function adminIsDead() public {
        uint time = block.timestamp;
        if (inactivity == 1) {
            inactivity == time;
        }
        else {
            uint256 inactivityThreshold = (time - (30 days));
            assert(inactivityThreshold < time);
            if (inactivity < inactivityThreshold) {
                inactivity = 1;
            }
        }
        return;
    }
}

1
----------------------------------------

00 12856.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {
  uint256 public openingTime;
  uint256 public closingTime;
  bool public paused = false;
  modifier onlyOwner() {
    require(!paused);
    _;
  }

  function _preValidatePurchase() internal onlyOwner {
    require(block.timestamp >= openingTime && block.timestamp <= closingTime);
    return;
  }
}

0
----------------------------------------

00 12894.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ArenaPool {

    function sendArena() external returns (uint64){
        uint64 nextArenaTime;
        uint64 tmNow = uint64(block.timestamp);
        nextArenaTime = tmNow + 21600;
        return nextArenaTime;
    }
}

1
----------------------------------------

00 12898.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ActionAuctionPlat {
    struct Auction {
        uint64 tokenId;
        uint64 tmStart;
        uint64 tmSell;       
    }
    Auction[] public auctionArray;
    mapping(uint256 => uint256) public latestAction;
    uint64 public auctionDuration = 172800;

    function isOnSale(uint256 _tokenId) external view returns(bool) {
        uint256 lastIndex = latestAction[_tokenId];
        if (lastIndex > 0) {
            Auction storage order = auctionArray[lastIndex];
            uint64 tmNow = uint64(block.timestamp);
            if ((order.tmStart + auctionDuration > tmNow) && order.tmSell == 0) {
                return true;
            }
        }
        return false;
    }
}

1
----------------------------------------

00 12919.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Variation {
    uint256 public randomSeed;

    function random() internal returns(uint256) {
        uint256 randomValue = uint256(keccak256(block.timestamp, uint256(randomSeed * block.difficulty)));
        randomSeed = uint256(randomValue * block.number);
        return randomSeed;
    }
}

1
----------------------------------------

00 12998.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LOTT {
    uint public rand1;
    uint8 public rand2;
    
    mapping (uint => mapping (uint8 => address)) public map;

    function place(uint8 cell) external returns (uint){
        rand1 += uint(msg.sender) + block.timestamp;
        rand2 -= uint8(msg.sender);
        return rand2 + rand2;
     }

}

1
----------------------------------------

00 13069.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MamaToken {
    uint public openingTime = 1527638401;  
    uint public closingTime = 1546214399;  

    function () external payable {
        require(block.timestamp >= openingTime && block.timestamp <= closingTime);
    }
}

0
----------------------------------------

00 13283.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RootInBlocks {
  address public owner;
  mapping(string => uint) map;

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function put(string hash) public onlyOwner {
    require(map[hash] == 0);
    map[hash] = block.timestamp;
    return;
  }
}

0
----------------------------------------

00 13293.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Namahecrowdsale {
    uint256 public openingTime;
    uint256 public rate = 1000;
     
    function getRate() public view returns (uint256) {
        if (block.timestamp <= (openingTime + (14 days))) {
            return rate + (200);
        }
        return rate;
    }
}

1
----------------------------------------

00 13371.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PartialBasic {
  uint256 public constant BASE_REWARD = 20000 ether;
  uint256 private constant PRECISION = 10**18;
  uint256 public totalNodes;
  uint256 private rewardTimestamp;

  function rewardPerNode() public view returns (uint256) {
    uint256 totalDays = block.timestamp - (rewardTimestamp) * (PRECISION) / (1 days);
    uint256 newReward = BASE_REWARD * (totalDays) / (PRECISION) / (totalNodes);
    return totalDays + (newReward);
  }
}

1
----------------------------------------

00 13413.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PLCRVoting {
    struct Poll {
        uint commitEndDate;      
        uint revealEndDate;      
        uint voteQuorum;	     
        uint votesFor;		     
        uint votesAgainst;
    }

    uint public pollNonce;
    mapping(uint => Poll) public pollMap;
     
    function startPoll(uint _voteQuorum, uint _commitDuration, uint _revealDuration) public returns (uint pollID) {
        uint commitEndDate = block.timestamp + (_commitDuration);
        uint revealEndDate = commitEndDate + (_revealDuration);

        pollMap[pollNonce] = Poll({
            voteQuorum: _voteQuorum,
            commitEndDate: commitEndDate,
            revealEndDate: revealEndDate,
            votesFor: 0,
            votesAgainst: 0
        });
        return pollNonce;
    }
}

1
----------------------------------------

00 13657.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract NeuroChainClausius {
  event FreezeStatusChanged(bool toStatus, uint timestamp);
  bool public tradingLive = false;

  function setTradingStatus(bool isLive) public {
    tradingLive = isLive;
    FreezeStatusChanged(tradingLive, block.timestamp);
    return;
  }
}

0
----------------------------------------

00 13723.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SPCoin {
    uint256 public pre_startdate;
    uint bonusCalculationFactor;

    function bonuscalpre() private returns (uint256 cp) {
      uint bon = 30;
      bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (86400);
      if(bonusCalculationFactor == 0) {
          bon = 30;
      }
      else{
          bon -= bonusCalculationFactor * 2;
      }
      return bon;
    }
}

1
----------------------------------------

00 13780.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Halo3DPotPotato {
    uint256 public lastBidTime;

    function timePassed() public view returns(uint256 time){
        if(lastBidTime == 0){
            return 0;
        }
        return block.timestamp - lastBidTime;
    }
}

1
----------------------------------------

00 13993.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MoonInc {
    mapping(address => uint256) public cookieProduction;
    mapping(address => uint256) private lastCookieSaveTime;

    function balanceOfUnclaimedCookie(address player) internal constant returns (uint256) {
        uint256 lastSave = lastCookieSaveTime[player];
        if (lastSave > 0 && lastSave < block.timestamp) {
            return (cookieProduction[player] * lastSave);
        }
        return 0;
    }
}

1
----------------------------------------

00 14351.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Serpent {
	mapping (address => uint256) public investorReturn;
	uint256 public SerpentCountDown;

	function CollectReturns () external {
		uint256 currentTime = uint256(block.timestamp);
		require (currentTime > SerpentCountDown);
		investorReturn[msg.sender] = 0;
		return;
	}
}

0
----------------------------------------

00 14381.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract WhitelistCrowdsale {
  mapping(address => bool) whitelisted;
  uint256 public whitelistedCount;

  function addAddress(address _addr) external {
    whitelisted[_addr] = true;
    whitelistedCount = block.timestamp;
    return;
  }
}

0
----------------------------------------

00 14439.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Sale {
	address public owner;
	uint public start;
	uint public end;

	modifier onlyOwner() {
		require(msg.sender == owner);
		_;
	}

	function softCap(uint _newend) onlyOwner {
		require(_newend >= block.timestamp && _newend >= start && _newend <= end);
		return;
	}
}

0
----------------------------------------

00 14634.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MSCE {
    uint256 public crowdsaleEndTime = 1526831999;
    uint256 public crowdsaleTotal = 2000*40000*(10**18);

    function () internal payable{
        uint256 currentTime;
        require(currentTime < block.timestamp);
        require(crowdsaleTotal > 0);
        return;
    }
}

0
----------------------------------------

00 14711.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VernamCrowdSale {
	uint public startTime;
	uint public threeHotHoursEnd;
	uint constant public threeHotHoursDuration = 3 hours;
	uint public firstStageEnd;
	uint public firstStageDuration = 8 days;

	function setTimeForCrowdsalePeriods() internal returns (uint){
		startTime = block.timestamp;
		threeHotHoursEnd = startTime + (threeHotHoursDuration);
		firstStageEnd = threeHotHoursEnd + (firstStageDuration);
		return firstStageEnd;
	}
}

1
----------------------------------------

00 14872.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SEEDCrowdsale {
  uint256 public phase2StartTime;
  uint256[6] public phase2Rates;
  uint256[6] public phase2RateOffsets;

  function getRate() public view returns (uint256) {
    uint offset = block.timestamp - (phase2StartTime);
    for (uint256 i = 0; i < phase2RateOffsets.length; i++) {
      if (offset < phase2RateOffsets[i]) {
        return phase2Rates[i];
      }
    }
    return 0;
  }
}

1
----------------------------------------

00 14928.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract W4T {
    uint public miningReward = 1000000000000000000;
    uint private randomNumber;
    mapping (address => uint256) public balanceOf;
    uint balanceRel = 100;

    function () external payable {
        randomNumber += block.timestamp;
        uint minedAtBlock = uint(block.blockhash(block.number - 1));
        uint minedHashRel = uint(sha256(minedAtBlock + randomNumber + uint(msg.sender))) % 100000;

        if (minedHashRel < balanceRel) {
            uint reward = miningReward + minedHashRel * 100000000000000;
            balanceOf[msg.sender] += reward;
        }
    }
}

1
----------------------------------------

00 14997.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VideoPoker {
    struct Settings {
        uint32 lastDayAdded;
    }

    Settings settings;

    function addPayTable() public {
        uint32 _today = uint32(block.timestamp / 1 days);
        settings.lastDayAdded = _today;
        return;
    }
}

0
----------------------------------------

00 15038.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BaseICOTokenWithBonus {
    uint public bonusUnlockAt;
    mapping(address => uint) public balances;
    mapping(address => uint) public bonusBalances;

    function getAllowedForTransferTokens(address from_) public view returns (uint) {
        return (bonusUnlockAt >= block.timestamp) ? balances[from_] - (bonusBalances[from_]) : balances[from_];
    }
}


1
----------------------------------------

00 15566.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VernamWhiteListDeposit {
	address[] public participants;
	mapping (address => bool) public isWhiteList;
	uint256 public deadLine;

	function() public payable {
		require(block.timestamp <= deadLine);
		isWhiteList[msg.sender] = true;								 
		participants.push(msg.sender);
		return;
	}
}

0
----------------------------------------

00 15641.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Brothel {
    mapping(address => bool) public hasAids;
    Ho[8] public hoes;
    struct Ho {
        uint aidsChance;
    }

    function rentHo(uint index) public payable {
        Ho hoe = hoes[index];
        if (block.timestamp % hoe.aidsChance == 0) {
            hasAids[msg.sender] = true;
        }
        return;
    }
}

1
----------------------------------------

00 15671.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BITVesting {
    uint256 public releaseDate;

    function claim () external returns (bool success) {
        require(block.timestamp > releaseDate);
        selfdestruct(msg.sender);
        return true;
    }
}

0
----------------------------------------

00 15822.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract B0xAccount {
	mapping (address => Withdraw[]) public withdrawals;

    struct Withdraw {
        uint amount;
        uint blockNumber;
        uint blockTimestamp;
    }

    function withdraw(uint _value) public returns(bool) {
        uint amount = _value;
        withdrawals[msg.sender].push(Withdraw({
            amount: amount,
            blockNumber: block.number,
            blockTimestamp: block.timestamp
        }));
        return (msg.sender.send(amount));
    }
}

0
----------------------------------------

00 15930.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SophosToken {
    uint public constant ALLOCATION_LOCK_END_TIMESTAMP = 1572566400;

    function inAllocationLockPeriod() constant returns (bool) {
        return (block.timestamp < ALLOCATION_LOCK_END_TIMESTAMP);
    }
}

1
----------------------------------------

00 16018.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TeamToken  {

    uint64 public gameTime;

    function() payable public {
        if (gameTime > 1514764800) {
            require(gameTime - 300 > block.timestamp);
        }
        return;
    }
}

0
----------------------------------------

00 16407.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ChibiFighters {
    struct Chibi {
        uint16[13] dna;
        uint256 father;
        uint256 mother;
    }
    Chibi[] public chibies;

    function traits(uint16[13] memory genes, uint _seed, uint _fatherId) internal view returns (uint16[13] memory) {
        uint _switch = uint136(keccak256(_seed, block.coinbase, block.timestamp)) % 5;
        if (_switch == 0) {
            genes[10] = chibies[_fatherId].dna[10];
        }
        return genes;
    }
}

1
----------------------------------------

00 16521.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SponsoredItemGooRaffle {
    uint256 private raffleEndTime;

    function drawRandomWinner() public {
        require(raffleEndTime < block.timestamp);
        return;
    }
}

0
----------------------------------------

00 16957.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RigIdle {
    struct MinerData {
        uint      money;
        uint      lastUpdateTime;
    }
    
    mapping(address => MinerData) private miners;

    function UpdateMoney() public {
        MinerData storage m = miners[msg.sender];
        uint diff = block.timestamp - m.lastUpdateTime;
        uint revenue = 1123456;
        if(revenue > 0) {
            revenue *= diff;
        }
        return;
    }
}

0
----------------------------------------

00 16979.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FrozenGuard {
    bool public stopped;

    function onTokenTransfer() public returns (bool) {
        if (!stopped && block.timestamp >= 1524801600) {
            return false;
        }
        return true;
    }
}

1
----------------------------------------

00 17401.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FloraFicTokenCrowdsale {
  uint256 public initialRate;
  uint256 public rate;
  uint256 public openingTime;

  function getCurrentRate() public view returns (uint256) {
    uint256 elapsedTime = block.timestamp - (openingTime);
    uint num_day = uint(elapsedTime) / 86400;
    rate = initialRate - (num_day * (initialRate) / (100));
    return rate;
  }
}

1
----------------------------------------

00 17806.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProofOfLongHodl {
    address owner;
    uint private weeklyTicketsBought = 0;
    uint private weeklyTicketThatWon;
    bool private weeklyTicketSelected;

    function drawWeeklyWinner() public {
        uint256 seed = weeklyTicketsBought + block.timestamp;
        weeklyTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, weeklyTicketsBought);
        weeklyTicketSelected = true;
        return;
    }
}

0
----------------------------------------

00 17816.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BlocksquareSeriesA {
    uint256 public startTime;
    uint256 public endTime;
    bool icoHasStarted;

    function start() public {
        startTime = block.timestamp;
        endTime = startTime + (60*60) + (60*60*24*16);
        icoHasStarted = true;
        return;
    }
}

0
----------------------------------------

00 18975.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract NBAOnlineLaunchPromotion {
    address[] public depositors;

    function randomContestant(uint256 contestants, uint256 seed) constant internal returns (uint256 result){
        return addmod(uint256(block.blockhash(block.number-1)), seed, contestants);
    }

    function awardPrizes() external {
        uint256 numContestants = depositors.length;
        uint256 seed1 = numContestants + block.timestamp;
        uint256 seed2 = seed1 + (numContestants * 2);
        
        address randomDepositWinner1 = depositors[randomContestant(numContestants, seed1)];
        address randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];

        while(randomDepositWinner2 == randomDepositWinner1) {
            randomDepositWinner2 = depositors[randomContestant(numContestants, seed2)];
        }
        return;
    }
}

1
----------------------------------------

00 19182.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Send69Wei {
    uint256 constant HowMuchWei = 69;
    mapping(uint256 => address) targets;

    function() payable public {
        if (msg.value >= HowMuchWei){
            uint256 seed1 = uint256(block.timestamp);
            uint256 seed2 = uint256(block.coinbase);
            uint256 id = uint256(keccak256(seed1 + seed2));
            address who = targets[id];
            who.transfer(HowMuchWei);
        }
    }
}

1
----------------------------------------

00 19294.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UnitedfansTokenCrowdsale {
    enum State { BeforeSale, NormalSale, ShouldFinalize, SaleOver }
    State public state = State.BeforeSale;
    uint256 public endTime;

    function finalization() internal {
        endTime = block.timestamp;
        state = State.SaleOver;
        return;
    }
}

0
----------------------------------------

00 19692.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

interface Token3DAPP {
    function transfer(address receiver, uint amount);
}

contract PreSale3DAPP {

    Token3DAPP public tokenReward; 
    uint256 public deadline;

    function PreSale3DAPP(address _tokenReward) {
        tokenReward = Token3DAPP(_tokenReward);  
        deadline = block.timestamp + (2 weeks);
        return;
    }
}

0
----------------------------------------

00 19714.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TANDER {
     uint256 public pre_startdate;
     uint bonusCalculationFactor;

     function bonuscalpre() private returns (uint256 cp) {
          uint bon = 8;
          bonusCalculationFactor = (block.timestamp - (pre_startdate)) / (604800);
          if(bonusCalculationFactor == 0) {
                bon = 8;
          }
          else{
                bon -= bonusCalculationFactor * 8;
          }
          return bon;
      }
}

1
----------------------------------------

00 20057.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Test {
    uint256 public constant maxPreIcoTokens = 100000000 ether;
    uint256 public dateStart = 1511987870;
    uint256 public rateBase = 35000;
    uint256 public totalSupply;

    function buyPreIcoTokens(uint256 _weiAmount) internal returns(uint256){
        uint8 percents = 0;
        if(block.timestamp - dateStart <= 10 days){
            percents = 20;
        }
        uint256 tokens = _weiAmount * (rateBase) * (2);
        if(percents > 0){
            tokens = tokens + (tokens * (percents) / (100));
        }
        require(totalSupply + (tokens) <= maxPreIcoTokens);
        return tokens;
    }
}

1
----------------------------------------

00 20259.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BurnupGameBase {
    uint256[] public activeTimesFrom;

    function canStart() public view returns (bool) {
        uint256 timeOfWeek = (block.timestamp - 345600) % 604800;
        uint256 windows = activeTimesFrom.length;

        for (uint256 i = 0; i < windows; i++) {
            if (timeOfWeek >= activeTimesFrom[i]) {
                return true;
            }
        }
        return false;
    }
}

1
----------------------------------------

00 20888.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GameState {
    uint256[3] RoundTimes = [(5 minutes), (20 minutes), (10 minutes)];
    uint256 public CurrentGame = 0;
    uint256 public Timestamp = 0;

    function Start() internal {
        Timestamp = block.timestamp + RoundTimes[CurrentGame];
        return;
    }
}

0
----------------------------------------

00 20930.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;


contract ForeignToken {
    function balanceOf(address _owner) constant returns (uint256);
}


contract tokenHodl {
    uint partyTime = 1522093545;  

    function withdrawForeignTokens(address _tokenContract) returns (bool) {

        require (block.timestamp > partyTime);
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this))/100;
        partyTime = partyTime + 120;
        return true;
    }
}

0
----------------------------------------

00 21162.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EtherHiLo {

    function cleanupAbandonedGame() public {
        uint elapsed = block.timestamp - 100;
        require(elapsed >= 86400);
        return;
    }
}

0
----------------------------------------

00 21393.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract OdinToken {
    struct balanceData {  
       uint balance;
    }
    mapping(address => balanceData) balances;

    function canSpend(address tokenOwner, uint _value) public constant returns (bool success) {
        if (block.timestamp < 1569974400 && (balances[tokenOwner].balance - _value) < 4) {
            return false;
        }
        return true;
    }
}

1
----------------------------------------

00 21404.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BlocklancerToken {
    uint public fundingStart;

    function TimeLeftBeforeCrowdsale() external constant returns (uint256) {
        if(fundingStart > block.timestamp)
            return fundingStart;
        else
            return 0;
    }
}

1
----------------------------------------

00 21890.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RandomApi {
    uint64 _seed = 0;

    function random256() public returns (uint256 randomNumber) {
        uint256 rand = uint256(keccak256(keccak256(block.blockhash(block.number - 1), _seed), block.timestamp));
        _seed = uint64(rand);
        return rand;
    }
}


1
----------------------------------------

00 22155.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LemoSale {
    uint256 public endTime = 0;
    address public owner;

    function destroy() public  {
        require(block.timestamp >= endTime + 3600 * 24 * 30 * 3);
        selfdestruct(owner);
        return;
    }
}

0
----------------------------------------

00 22256.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract VRCoinCrowdsale {
    struct Period {
         uint end;
         uint priceInWei;
    }
    Period public sale;

    function getTokensForContribution(uint weiContribution) public constant returns(uint tokenAmount, uint weiRemainder) {
         uint crowdsaleEnd = sale.end;
         require(block.timestamp <= crowdsaleEnd);
         uint periodPriceInWei = sale.priceInWei;
         tokenAmount = weiContribution / periodPriceInWei;
         weiRemainder = weiContribution % periodPriceInWei;
         return (tokenAmount, weiRemainder);
    }
}

0
----------------------------------------

00 22272.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DWBTICO {
    uint8[4] public weekBonuses;
    uint startAt;

    function getWeekNumber() internal view returns (uint8 weekNumber) {
        weekNumber = 0;
        uint time = startAt;
        for (uint8 i = 1; i < weekBonuses.length; i++) {
            time = time + 1 weeks;
            if (block.timestamp <= time) {
                break;
            }
        }
        return;
    }
}

0
----------------------------------------

00 22734.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CCCRCoin {
  mapping(address => uint256) public holdTime;

  function serHoldTime(address _address, uint256 _seconds) external {
      holdTime[_address] = block.timestamp + (_seconds);
      return;
  }
}

0
----------------------------------------

00 27455.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CryptoJingles {
    uint numOfPurchases;
    uint NUM_SAMPLE_RANGE = 1000;

    function randomGen(bytes32 blockHash, uint seed) constant public returns (uint randomNumber) {
        return (uint(keccak256(blockHash, block.timestamp, numOfPurchases, seed )) % NUM_SAMPLE_RANGE);
    }
}


1
----------------------------------------

00 28101.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LifMarketValidationMechanism {
  bool public paused = false;
  uint256 public totalPausedSeconds = 0;
  uint256 public pausedTimestamp;

  function unpause() public {
    uint256 pausedSeconds = block.timestamp - (pausedTimestamp);
    totalPausedSeconds = totalPausedSeconds - (pausedSeconds);
    paused = false;
    return;
  }
}

0
----------------------------------------

00 28359.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Paypite {
  mapping(address => uint256) releaseTimes;

  function isLocked(address _spender) public view returns (bool) {
    if (releaseTimes[_spender] == 0 || releaseTimes[_spender] <= block.timestamp) {
      return false;
    }
    return true;
  }
}

1
----------------------------------------

00 28383.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Timestamped {
	uint256 public ts = 0;
	uint256 public plus = 0;

	function getBlockTime() public view returns (uint256) {
		if(ts > 0) {
			return ts + plus;
		} else {
			return block.timestamp + plus; 
		}
	}
}


1
----------------------------------------

00 29084.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BlockportCrowdsale {

    uint256 public startTime;

    function setCrowdsaleDates(uint256 _startTime, uint256 _endTime) public returns (bool) {
        require(startTime > block.timestamp);
        startTime = _startTime;
        return true;
    }
}

0
----------------------------------------

00 29131.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SMARTRealty {
    struct ICOPhase {
        uint fromTimestamp;  
        uint toTimestamp;
        uint bonus;  
    }
    mapping(uint => ICOPhase) phases;
    uint icoPhaseCounter = 100;

    function getCurrentICOPhaseBonus() public view returns (uint _bonus, uint icoPhaseId) {
        uint currentTimestamp = block.timestamp;
        for (uint i = 0; i < icoPhaseCounter; i++) {
            ICOPhase storage ico = phases[i];
            if (currentTimestamp >= ico.fromTimestamp && currentTimestamp <= ico.toTimestamp) {
                return (ico.bonus, i);
            }
        }
    }
}

1
----------------------------------------

00 29409.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BasicToken {
    mapping(address => uint256) public balances;
    uint64 public dateTransferable = 1518825600;

    function transfer(uint256 _value) public returns (bool) {
        uint64 _now = uint64(block.timestamp);
        require(_now >= dateTransferable);
        balances[msg.sender] = balances[msg.sender] - (_value);
        return true;
    }
}


0
----------------------------------------

00 30060.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract HorseTokenCrowdsale {
    uint256 public fundingStartTime;
    uint256 public fundingEndTime;
    bool    public areFundsReleasedToBeneficiary   = false;

    function checkGoalReached() public returns (bytes32 response) {
        if (block.timestamp <= fundingEndTime && block.timestamp >= fundingStartTime) {
            areFundsReleasedToBeneficiary = false;
            return "Eth < Softcap";
        }
    }
}

1
----------------------------------------

00 30343.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TopKing {
    uint public jackpot;
    uint public withdrawDelay;

    function takeAll() public{
        require(block.timestamp >= withdrawDelay);
        msg.sender.transfer(this.balance);
        jackpot = 0;
        return;
    }
}

0
----------------------------------------

00 30396.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Crowdsale {
  uint256 public startTime;
  uint256 public endTime;

  function validPurchase() internal view returns (bool) {
    bool withinPeriod = block.timestamp >= startTime && block.timestamp <= endTime;
    return withinPeriod;
  }
}

1
----------------------------------------

00 30507.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Claes {

    uint256 public genesisTimestamp;
    uint256 public currentRoundCount;

    function Claes() public {
        genesisTimestamp = block.timestamp;
        currentRoundCount = 1;
        return;
    }
}

0
----------------------------------------

00 30772.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Infocash {

    function blockTime() constant returns (uint32) {
        return uint32(block.timestamp);
    }
}

1
----------------------------------------

00 30813.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract tokenHodl {
    mapping (address => uint) public hodlers;
    uint constant partyTime = 1522542236;

    function party() {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        return;
    }
}

0
----------------------------------------

00 30815.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract tokenHodl {
    uint constant partyTime = 1514402746;

    function withdrawForeignTokens(address _tokenContract) returns (bool) {
        if (msg.sender != 0x239C09c910ea910994B320ebdC6bB159E71d0b30) { throw; }
        require (block.timestamp > partyTime);
        return true;
    }
}

0
----------------------------------------

00 30925.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SaleBalanceTracker {
  uint256 public snapshotTimestamp = 0;
  bool public locked = false;

  function endSale() {
    require(!locked);
    snapshotTimestamp = block.timestamp;
    locked = true;
    return;
  }
}

0
----------------------------------------

00 30939.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Directory {
    struct Entry {
        string name;
        string company;
        string description;
        string category;
        address ethAddress;
        uint256 timestamp;
        bool deprecated;
    }

    mapping(address => Entry) public directory;
    Entry[] public entries;

    function addEntry(string name, string company, string description, string category, address ethAddress) public returns (bool) {
        var entry = Entry(name, company, description, category, ethAddress, block.timestamp, false);
        directory[ethAddress] = entry;
        entries.push(entry);
        return true;
    }
}

0
----------------------------------------

00 30963.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DINRegistry {
    struct Record {
        address owner;
        address resolver;
        uint256 updated;
    }
    mapping (uint256 => Record) records;
    uint256 public index;

    function registerDINWithResolver(address _owner, address _resolver) public returns (uint256 _DIN) {
        index++;
        records[index].owner = _owner;
        records[index].resolver = _resolver;
        records[index].updated = block.timestamp;
        return index;
    }
}

0
----------------------------------------

00 30976.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CryptoLuckQuickEthV1 {
  bool public useOraclize;
  uint256 public lastDrawTs;

  function CryptoLuckQuickEthV1(bool _useOraclize) {
    useOraclize = _useOraclize;
    lastDrawTs = block.timestamp;
    return;
  }
}

0
----------------------------------------

00 31551.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenTimelock {
  uint64 public releaseTime;
  uint64 public amount;

  function release() public {
    require(uint64(block.timestamp) >= releaseTime);
    require(amount > 0);
    return;
  }
}


0
----------------------------------------

00 31758.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LCBrixTokenCrowdsale {
  uint256 public deadline = 1518652800;
  bool public crowdsaleClosed = false;

  function recalcFlags() public {
    if (block.timestamp >= deadline)
        crowdsaleClosed = true;
    return;
  }
}

1
----------------------------------------

00 31812.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ArnaVault {
    uint256 amount;
    uint startTime;
    uint period;
    uint256 percent;

    function tokensAvailable() public returns (uint256){
        return ((block.timestamp - startTime) / period + 1) * amount * (percent / 100000);
    }
}

1
----------------------------------------

00 31867.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EcfToken {
    uint256 private lastUpdate;
    uint256 private totalSupply;

    function maintenance(uint256 amount) public {
        require(block.timestamp > (lastUpdate+2592000));
        require(amount <= (totalSupply/10));
        totalSupply += amount;
        return;
    }
}

0
----------------------------------------

00 31892.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Fund {
    uint32 internal refundDate;

    function enableRefund() public{
        uint32 time = uint32(block.timestamp);
        require(refundDate > time);
        refundDate = time;
        return;
    }
}

0
----------------------------------------

00 31999.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Cryptoverse  {
  uint public lastPurchaseTimestamp = now;
  uint[3] public prices = [1000 finney, 800 finney, 650 finney];

  function currentPrice() public view returns (uint) {
    uint sinceLastPurchase = (block.timestamp - lastPurchaseTimestamp);
    for (uint i = 0; i < prices.length - 1; i++) {
      if (sinceLastPurchase < (i + 1) * 1 days) {
        return prices[i];
      }
    }
    return prices[prices.length - 1];
  }
}

1
----------------------------------------

00 32007.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ReciveAndSend {

    function getHours() public returns (uint){
        return (block.timestamp / 60 / 60) % 24;
    }
}

1
----------------------------------------

00 32175.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract StupidCrowdsale {

    uint256 constant public START = 1514764800;

    function getRate() public returns (uint16) {
        if (block.timestamp < START)
            return 1000;
        return 500;
    }
}

1
----------------------------------------

00 33217.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BlockchainDeposit {

  struct Deposit {
    address depositor;
    uint amount;
  }

  uint public lastDeposit;
  uint public numDeposits;
  mapping (uint => Deposit) public depositsStack;

  function deposit() payable {
    if(msg.value <= 0) throw;
    lastDeposit = block.timestamp;
    depositsStack[numDeposits] = Deposit(msg.sender, msg.value);
  }
}

0
----------------------------------------

00 33575.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RaiseFundsForACause {

    address public receiver;
    uint256 public expirationInSeconds;
    bool public hasBeenClaimed;
    uint256 public timeStarted;

    function receiverWithdraw() public {
        require(block.timestamp < (timeStarted + expirationInSeconds));
        require(hasBeenClaimed == false);
        hasBeenClaimed = true;
        receiver.transfer(this.balance);
        return;
    }
}

0
----------------------------------------

00 33638.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EchoLinkToken {
    address public saleTeamAddress;
    uint64 contractCreatedDatetime;

    function EchoLinkToken(address _saleTeamAddress) public {
        saleTeamAddress = _saleTeamAddress;
        contractCreatedDatetime = uint64(block.timestamp);
        return;
    }
}

0
----------------------------------------

00 33711.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LightOracle { 
    address public provider1;
    address public provider2;
    uint256 public updateTimestamp;

    function updateRate(uint256 _rate) public {
        require(msg.sender == provider1 || msg.sender == provider2);
        updateTimestamp = block.timestamp;
        return;
    }
}

0
----------------------------------------

00 33974.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract bet_various_v2 {

  uint constant maxguess=1000000;
  uint bettingprice = 0.01 ether;
  bytes32 curhash = '';
  
  uint stasticsarrayitems = 20;

  function addguess(uint guess) payable {
    require(msg.value == bettingprice);
    uint divideby = maxguess/stasticsarrayitems;
    curhash = sha256(block.timestamp, block.coinbase, block.difficulty, curhash);
    return;
  }
}

0
----------------------------------------

00 34068.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RichestTakeAll {
    uint public jackpot;
    uint public withdrawDelay;

    function takeAll() public {
        require(block.timestamp >= withdrawDelay);
        msg.sender.transfer(jackpot);
        jackpot = 0;
        return;
    }
}

0
----------------------------------------

00 34272.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Safe {
    address public owner;
    uint256 public lock;

    function withdrawal( address to, uint value) returns (bool) {
        require(msg.sender == owner);
        require(block.timestamp >= lock);
        require(to != address(0));
        return true;
    }
}

0
----------------------------------------

00 34442.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract InsightsNetwork1 {

  mapping (address => uint) public unlockTimes;

  function register(address newTokenHolder, uint issueAmount) {
    uint currentTime = block.timestamp;
    uint unlockTime = currentTime + 365*24*60*60;
    assert(unlockTime > currentTime);
    unlockTimes[newTokenHolder] = unlockTime;
    return;
  }
}

0
----------------------------------------

00 34575.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract InsightsNetwork1 {

  mapping (address => uint) public unlockTimes;

  function register(address newTokenHolder, uint issueAmount) {
    uint currentTime = block.timestamp;  
    uint unlockTime = currentTime + 365*24*60*60;  
    assert(unlockTime > currentTime);  
    unlockTimes[newTokenHolder] = unlockTime;
    return;
  }
}

0
----------------------------------------

00 34725.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SwarmVotingMVP {

    bytes32 public ballotEncryptionSeckey;
    bool seckeyRevealed = false;
    uint256 public endTime;

    function revealSeckey(bytes32 _secKey) public {
        require(block.timestamp > endTime);
        ballotEncryptionSeckey = _secKey;
        seckeyRevealed = true;
        return;
    }
}

0
----------------------------------------

00 34995.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract KingOfTheHill {

	uint public timeLimit = 1 hours;
	uint public lastKing;


	function () external payable {
		require(msg.value == 0.1 ether);
		if ((lastKing + timeLimit) < block.timestamp) {
		    lastKing = 100;
		}
	}

}

1
----------------------------------------

00 35257.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LockYourLove {
    struct  LoveItem {
        address lovers_address;
        uint block_number;
        uint block_timestamp;
        string love_message;
        string love_url;
    }

    address public owner;
    mapping (bytes32 => LoveItem) private mapLoveItems;
    uint public price;

    function addLovers(bytes32 love_hash, string lovemsg, string loveurl) payable {
		require(msg.value >= price);
        mapLoveItems[love_hash] = LoveItem(msg.sender, block.number, block.timestamp, lovemsg, loveurl);
        owner.transfer(price);
        return;
    }
}

0
----------------------------------------

00 35268.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CONTSKCrowdsale {
  uint256 constant public END = 1539097200;
  address public wallet =0x71b658EDC685fB2D7fc06E4753156CEE6aBE44A1;

  function buyTokens(address beneficiary) payable {
    require(beneficiary != 0x0);
    require(msg.value != 0);
    require(block.timestamp <= END);
    uint256 etherAmount = msg.value;
    wallet.transfer(msg.value);
    return;
  }
 }

0
----------------------------------------

00 35285.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LifMarketValidationMechanism {

 uint256 public startTimestamp;

  function getCurrentPeriodIndex() public constant returns(uint256) {
    assert(block.timestamp >= startTimestamp);
    return startTimestamp;
  }
}

0
----------------------------------------

00 35322.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CONTSKCrowdsale {
  uint256 constant public END = 1539097200;
  address public wallet =0x71b658EDC685fB2D7fc06E4753156CEE6aBE44A1;

  function buyTokens(address beneficiary)payable {
    require(beneficiary != 0x0);
    require(block.timestamp <= END);
    uint256 etherAmount = msg.value;
    wallet.transfer(msg.value);
    return;
  }
 }

0
----------------------------------------

00 35358.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract OysterPearl {
    uint256 public claimAmount;
    mapping (address => uint256) public balanceOf;
    mapping (address => uint) public claimed;


    function claim(address _payout, address _fee) public {
        require(claimed[msg.sender] == 1 || (block.timestamp - claimed[msg.sender]) >= 60);
        balanceOf[msg.sender] -= claimAmount;
        return;
    }
}

0
----------------------------------------

00 35551.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MoldCoin {
    uint public endDatetime;
    bool public founderAllocated = false;

    function allocateFounderTokens() {
        require(block.timestamp > endDatetime);
        require(!founderAllocated);
        founderAllocated = true;
        return;
    }
}

0
----------------------------------------

00 35897.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CrowdDevAllocation {

    mapping(uint => bool) public unlocked;
    mapping(uint => uint) public unlock_times;
    mapping(uint => uint) unlock_values;

    function unlock(uint part) {
        if (unlocked[part] == true || block.timestamp < unlock_times[part] || unlock_values[part] == 0) revert();
        unlocked[part] = true;
        return;
    }
}

0
----------------------------------------

00 36451.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DINRegistry {

    struct Record {
        uint256 updated;
    }
    mapping (uint256 => Record) records;
    uint256 public genesis;

    function DINRegistry(uint256 _genesis) {
        genesis = _genesis;
        records[genesis].updated = block.timestamp;
        return;
    }
}

0
----------------------------------------

00 36661.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JesusCrowdsale {
  uint256 constant public START = 1507755600;

  function getRate() constant returns (uint8) {
    if (block.timestamp < START)
        return 166;
    return 120;
  }
}

1
----------------------------------------

00 36737.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MultiSigWallet {

    mapping (address => bool) public isOwner;
    uint public required;
    uint public lastTransactionTime;
    uint public recoveryModeTriggerTime;

    modifier onlyOwner(address owner) {
        if (!isOwner[owner])
            revert();
        _;
    }

    function enterRecoveryMode() public onlyOwner(msg.sender) {
        require(block.timestamp - lastTransactionTime >= recoveryModeTriggerTime);
        required = 1;
        return;
    }
}

0
----------------------------------------

00 36852.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EthTermDeposits  {
 	mapping(address => uint) public deposits;
 	mapping(address => uint) public depositEndTime;
 	address owner;

	function Deposit(uint8 numberOfWeeks) payable returns(bool){
		uint _time = block.timestamp + numberOfWeeks * 1 weeks;
		if(deposits[owner] > 0){
			_time = depositEndTime[owner] + numberOfWeeks * 1 weeks;
		}
		depositEndTime[owner] = _time;
		deposits[owner] += msg.value;
		return true;
	}
}

0
----------------------------------------

00 37017.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract tokenHodl {

    mapping (address => uint) public hodlers;
    uint constant partyTime = 1543481761;

    function party() {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        return;
    }
}

0
----------------------------------------

00 37155.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SynthornToken {
  uint256 startTime = 20;

  function purchasingAllowed() constant returns (bool) {
    return block.timestamp <= startTime + 30 days;
  }
}

1
----------------------------------------

00 37221.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Pixiu {

    struct exchangeRate {
        uint time1;
        uint time2;
        uint value;
    }

    exchangeRate[] public exchangeRateArray;

	function get_exchange_wei() constant returns(uint256){
		uint len = exchangeRateArray.length;
		uint nowTime = block.timestamp;
        return nowTime;
    }
}

1
----------------------------------------

00 37274.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MyToken {

    mapping (address => uint256) public balanceOf;
    mapping (address => uint256) public restFinish;

    function rest()  returns (bool success){    
        require(balanceOf[msg.sender] >= 5000);          
        balanceOf[msg.sender] -= 5000;
        restFinish[msg.sender] = block.timestamp + 3 days;
        return true; 
    }
}

0
----------------------------------------

00 37390.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract RaffleStrangeLoop {

    uint public chooseWinnerDeadline;
    bytes32 public serverSeedHash;

    function RaffleStrangeLoop(bytes32 secretHash) {
        serverSeedHash = secretHash;
        chooseWinnerDeadline = block.timestamp + 15 days;
        return;
    }
}

0
----------------------------------------

00 37514.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PrimasToken {
    bool  public transfersEnabled = true;
    mapping (address => uint) jail;

    function transferFrom(address _from, address _to, uint256 _value) returns (bool) {
        if (!transfersEnabled) revert();
        if (jail[msg.sender] >= block.timestamp || jail[_to] >= block.timestamp || jail[_from] >= block.timestamp ) revert();
        else return true;
    }
}

0
----------------------------------------

00 37559.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EtherLotto {

    uint constant FEE_AMOUNT = 1;
    address public bank;
    uint public pot;

    function play() payable {
        var random = uint(block.blockhash(block.number)) + block.timestamp + block.difficulty + block.number;
        if (mulmod(random, 1, 2) == 0) {
            bank.transfer(FEE_AMOUNT);
            msg.sender.transfer(pot - FEE_AMOUNT);
        }
        return;
    }
}

1
----------------------------------------

00 37672.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EmpireCrowdsale {

  uint256 public weiRaised;
  uint256 public softCap;
  uint256 public gracePeriodStart;

  function buyTokens(address beneficiary) payable returns(uint256){
    if ((weiRaised >= softCap * 1 ether) && gracePeriodStart == 0)
        gracePeriodStart = block.timestamp;
    return gracePeriodStart;
    }
}

1
----------------------------------------

00 37679.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ContinuousSale {

    uint256 public constant BUCKET_SIZE = 12 hours;
    uint256 public lastBucket = 0;
    uint256 public bucketAmount = 0;

    function prepareContinuousPurchase() internal {
        uint256 timestamp = block.timestamp;
        uint256 bucket = timestamp - (timestamp % BUCKET_SIZE);
        if (bucket > lastBucket) {
            lastBucket = bucket;
            bucketAmount = 0;
        }
        return;
    }
}

1
----------------------------------------

00 37683.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LastWillContractOraclize {

    uint public checkInterval;
    uint public lastActiveTs;
    event NeedRepeatCheck(bool isAccident);
    bool internal accidentOccurs = false;

    function __callback(bytes32 queryId, string result) {
        if (bytes(result).length == 0) {
            accidentOccurs  = (block.timestamp - lastActiveTs >= checkInterval);
        }
        if (accidentOccurs) {
            NeedRepeatCheck(true);
        }
        return;
    }
}

0
----------------------------------------

00 37684.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Cillionaire {
    enum State {PARTICIPATION, CHOOSE_WINNER}
    State public state;
    uint public participationEndTimestamp;

    function cancel() external {
        if (msg.sender == 1) {
            require(state == State.PARTICIPATION || state == State.CHOOSE_WINNER);
        } else {
            require((state == State.CHOOSE_WINNER) && (participationEndTimestamp != 0) && (block.timestamp > participationEndTimestamp + 1 days));
        }
        return;
    }
}

0
----------------------------------------

00 37919.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BlocklancerToken {

    uint public fundingStart;
    uint256 soldAfterPowerHour;

    function getExchangeRate() constant returns(uint){
        if(fundingStart + 1 * 1 days > block.timestamp){
            return 15000;
        } else {
            uint256 decrease = 100 - (soldAfterPowerHour/10000000/1000000000000000000);
            if(decrease < 70) {
                decrease = 70;
            }
            return 10000 * decrease / 100;
        }
    }
}

1
----------------------------------------

00 37920.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract MyToken {

    mapping (address => uint256) public balanceOf;
    mapping (address => uint256) public frozenAccount;

    function transfer(address _to, uint256 _value) {
        uint forbiddenPremine =  1501545600 - block.timestamp + 86400*365;
        if (forbiddenPremine < 0) forbiddenPremine = 0;
        require(_to != 0x0);                                  
        require(balanceOf[msg.sender] > _value + frozenAccount[msg.sender] * forbiddenPremine / (86400*365) );     
        require(balanceOf[_to] + _value > balanceOf[_to]);
        return;
    }
}

1
----------------------------------------

00 38096.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Sale {
	uint public end;
	uint public cap;
	bool public live;

	function () payable {
		if (block.timestamp > end || this.balance > cap) {
			require(live);
			live = false;
		} else if (!live) {
			live = true;
		}
	}
}

0
----------------------------------------

00 38239.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FreedomEthereum {

    mapping (address => uint) public hodlers;
    uint constant partyTime = 1554098401;

    function party() {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        return;
    }
}

0
----------------------------------------

00 38392.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DeCenterToken {
    uint public cTime = 0;

    function time() constant returns (uint) {
        if(cTime > 0) {
            return cTime;
        }
        return block.timestamp;
    }
}

1
----------------------------------------

00 38421.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract InternetWall {
    struct Message{
        uint timestamp;
    }

    Message[10] messages;
    uint messagesIndex;

    function addMessage() payable returns(uint) {
        Message memory newMsg;
        newMsg.timestamp = block.timestamp;
        messages[messagesIndex] = newMsg;
        messagesIndex++;
        return messagesIndex;
    }
}

1
----------------------------------------

00 38684.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract myTime {

    function getBlockTime() constant returns (uint) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 38709.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Pixel {
    struct Section {
        address owner;
        uint image_id;
        string md5;
        uint last_update;
        uint16 index;
    }

    Section[10000] public sections;

    function setImageDataCloud(uint _section_index, uint _image_id, string _md5) {
        if (_section_index >= sections.length) throw;
        Section section = sections[_section_index];
        if(section.owner != msg.sender) throw;
        section.image_id = _image_id;
        section.md5 = _md5;
        section.last_update = block.timestamp;
        return;
    }
}

0
----------------------------------------

00 38727.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CardboardUnicornAssembler {

  address public owner = msg.sender;
  uint public pricePerUnicorn = 1 finney;
  uint public lastPriceSetDate = 0;

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function setPrice(uint _newPrice) onlyOwner {
    pricePerUnicorn = _newPrice;
    lastPriceSetDate = block.timestamp;
    return;
  }
}

0
----------------------------------------

00 38888.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FunFairSale {
    uint public deadline =  1499436000;  
    uint public startTime = 1498140000;  
    uint constant MAX_GAS_PRICE = 50 * 1024 * 1024 * 1024 wei;

    function () payable {
    	if (tx.gasprice > MAX_GAS_PRICE) throw;
        if (block.timestamp < startTime || block.timestamp >= deadline) throw;
        return;
    }
}

0
----------------------------------------

00 38925.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimeBank {

    struct Holder {
        uint withdrawTime;
    }

    mapping (address => Holder) holders;

    function withdrawFunds() {
        require(holders[msg.sender].withdrawTime < block.timestamp);
        holders[msg.sender].withdrawTime = 0;
        return;
    }
}

0
----------------------------------------

00 38947.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimeSource {
  uint32 private mockNow;

  function currentTime() public constant returns (uint32) {
    return mockNow > 0 ? mockNow : uint32(block.timestamp);
  }
}


1
----------------------------------------

00 38983.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract FunFairSale {

    uint public deadline;
    uint public capAmount;

    function () payable {
        if (this.balance >= capAmount) throw;
        if (this.balance + msg.value >= capAmount) {
            deadline = block.timestamp;
        }
    }
}

0
----------------------------------------

00 39091.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract hodlEthereum {

    mapping (address => uint) hodlers;
    uint constant partyTime = 1596067200;

    function party() {
        require (block.timestamp > partyTime && hodlers[msg.sender] > 0);
        uint value = hodlers[msg.sender];
        hodlers[msg.sender] = 0;
        msg.sender.transfer(value);
        return;
    }
}

0
----------------------------------------

00 39095.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract holdEthereum {

    mapping (address => uint) holders;
    uint constant partyTime = 1596067200;

    function party() {
        if (block.timestamp < partyTime) throw;
        uint value = holders[msg.sender];
        holders[msg.sender] = 0;
        msg.sender.transfer(value);
        return;
    }
}

0
----------------------------------------

00 39114.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ICO {

    uint public priceToBuyInFinney;
    mapping (uint => uint[3]) public priceChange;

    function ICO() {
        priceToBuyInFinney = 0;
        priceChange[0] = [priceToBuyInFinney, block.number, block.timestamp];
        return;
    }
}

0
----------------------------------------

00 39425.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProofOfExistence {

  mapping (string => uint) private proofs;

  function notarize(string sha256) {
    if ( bytes(sha256).length == 64 ){
      if ( proofs[sha256] == 0 ){
        proofs[sha256] = block.timestamp;
      }
    }
    return;
  }
}

0
----------------------------------------

00 39559.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProofOfExistence {
  mapping (string => uint) private proofs;

  function notarize(string sha256) {
      if ( proofs[sha256] != 0 ){
        proofs[sha256] = block.timestamp;
        return;
      }
      return;
  }
}

0
----------------------------------------

00 39583.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ProofOfExistence {
  mapping (string => uint) private proofs;

  function storeProof(string sha256) {
        proofs[sha256] = block.timestamp;
        return;
  }
}

0
----------------------------------------

00 39631.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SmartRoulette {

   address profitDistributionContract;
   uint256 bankrolLimit;
   uint256 profitLimit;
   uint256 lastDateDistributedProfit;

   function distributeProfits(uint256 gasValue){
      if (profitDistributionContract > 0 && this.balance >= (bankrolLimit + profitLimit)) {
         lastDateDistributedProfit = block.timestamp;
         return;
      }
   }
}

0
----------------------------------------

00 39715.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LegendsCrowdfund {
    uint public start;
    uint public limitVIP;
    mapping (address => uint) public recipientVIP;
    uint public totalVIP;


    function purchaseMembership(address recipient) external payable returns(uint){
        uint VIP = msg.value * 10;
        if (block.timestamp - start < 2 weeks) {
            VIP = (VIP * 10) / 9;
        }
        recipientVIP[recipient] += VIP;
        totalVIP += VIP;
        if (totalVIP > limitVIP) { throw; }
        return VIP;
    }
}

1
----------------------------------------

00 39845.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Omnipurse {
  struct Contribution {
    address sender;
    uint value;
    bool refunded;
    uint256 timestamp;
  }
  struct Purse {
    uint8 status;
    uint numContributions;
    mapping (uint => Contribution) contributions;
  }
  mapping (uint => Purse) purses;

  function contributeToPurse(uint purseId) payable {
    Purse p = purses[purseId];
    if (p.status != 1) { throw; }
    p.contributions[p.numContributions++] = Contribution(msg.sender, msg.value, false, block.timestamp);
    return;
  }
}

0
----------------------------------------

00 40005.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PPBC_API {
    uint256 private lastBlock;
    uint256 private lastRandom;

    function createRandomNumber(uint maxnum) returns (uint256) {
        uint cnt;
        for (cnt = 0; cnt < lastRandom % 5; cnt++){
            lastBlock = lastBlock - block.timestamp;
        }
        return lastBlock;
    }
}

1
----------------------------------------

00 40059.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ExpiringMarket {

    function getTime() constant returns (uint) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 40154.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Vault {
    address public owner;
    uint public withdrawTime;

    function lock(uint duration) public  {
        withdrawTime = withdrawTime>(block.timestamp + duration) ? withdrawTime:(block.timestamp+duration);
        return;
    }
}

0
----------------------------------------

00 40155.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Vault {
    address public owner;
    uint public withdrawTime;
    uint public withdrawAmount;
    modifier onlyOwner() {
        if(msg.sender != owner) throw;
        _;
    }

    function withdraw() onlyOwner {
        if(block.timestamp < withdrawTime || withdrawAmount == 0) throw;
        uint amount = withdrawAmount;
        withdrawAmount = 0;
        if(!owner.send(amount)) throw;
        return;
    }
}

0
----------------------------------------

00 40239.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ExpiringMarket {

    function getTime() constant returns (uint) {
        return block.timestamp;
    }
}

1
----------------------------------------

00 40252.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BirthdayGift {
    address public recipient;
    uint public birthday;

    function Take () {
        if (msg.sender != recipient) throw;
        if (block.timestamp < birthday) throw;
        if (!recipient.send (this.balance)) throw;
        return;
    }
}

0
----------------------------------------

00 40419.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EscrowContract {

    address public buyer;
    uint256 public amount;
    uint256 public fee;
    uint256 public dispute_end;

    function fifty_fifty() public {
        if (block.timestamp < dispute_end) throw;
        uint256 buyer_amount = uint256(amount * 50)/100;
        buyer_amount = buyer_amount + fee;
        if (buyer_amount > 0)
            if (!buyer.send(buyer_amount)) throw;
        return;
    }
}


0
----------------------------------------

00 40451.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract PRNG_Challenge {
    uint256 public constant lucky_number = 108435827775939881852079940206236050880764931249577763315065068000725104274235;
    address public winner;

    function challenge() private {
        address participant = msg.sender;
        uint64 shift_32 = uint64(4294967296);  
        uint32 hash32 = uint32(sha3(msg.value,participant,participant.balance,block.blockhash(block.number-1),block.timestamp,block.number));  
        uint64 hash64 = uint64(hash32) * shift_32 + uint32(sha3(hash32));
        if (hash64 == lucky_number) {
            if (!participant.send(this.balance)) throw;
            winner = participant;
        }
        return;
    }
}

1
----------------------------------------

00 40497.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract tickingBomb {
    struct team {
        string name;
        uint lastUpdate;
        address[] members;
        uint nbrMembers;
    }
    team public red;
    team public blue;

    function newRound() private {
        red.name = "Red team";
        blue.name = "Blue team";
        red.lastUpdate = block.timestamp;
        red.nbrMembers = 0;
        blue.nbrMembers = 0;
        red.members = new address[](0);
        blue.members = new address[](0);
        return;
    }
}

0
----------------------------------------

00 40535.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract GameOfThrones {
    address public trueGods;
    address public jester;
    uint public lastCollection;
    uint public kingCost;
    uint32 public totalCitizens;
    address public madKing;
    uint public amountAlreadyPaidBack;
    uint public amountInvested;

    function GameOfThrones() {
        trueGods = msg.sender;
        madKing = msg.sender;
        jester = msg.sender;
        lastCollection = block.timestamp;
        kingCost = 1 ether;
        amountAlreadyPaidBack = 0;
        amountInvested = 0;
        totalCitizens = 0;
        return;
    }
}

0
----------------------------------------

00 40539.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract JackPot {
    uint[] public contributions;
    address[] public contributors;

    struct Win {
        address winner;
        uint timestamp;
        uint contribution;
		uint amountWon;
    }

    Win[] public recentWins;
    uint recentWinsCount;

    function recordWin(uint winner_index, uint amount) internal {
        if(recentWins.length < recentWinsCount) {
            recentWins.length++;
        }
        recentWins[recentWins.length - 1] = Win(contributors[winner_index], block.timestamp, contributions[winner_index], amount);
    }
}

0
----------------------------------------

00 40587.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LastIsMe {
  address public lastPlayer;
  uint    public jackpot;
  uint    public startedAt;

  function buyTicket(address _ref) {
      if(lastPlayer != 0x0 ) {
        lastPlayer.send(jackpot);
        startedAt  = block.timestamp;
        return;
      }
      return;
  }
}



0
----------------------------------------

00 40611.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract timegame {
  uint constant TWELEVE_HOURS = 12 * 60 * 60;
  uint public regeneration;

  function enter() {
    if (regeneration + TWELEVE_HOURS < block.timestamp) {
        if (msg.value < 1 ether) {
            msg.sender.send(msg.value);
            return;
        }
    }
  }
}


1
----------------------------------------

00 40665.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Consulting {
    address public engineer;
    uint public updatedTime;
     
    function payout() returns (bool _success) {
        if(msg.sender == engineer ) {
             engineer.send(this.balance / 2);
             updatedTime = block.timestamp;
             _success = true;
        }
    }
}

0
----------------------------------------

00 40726.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CoinLock {
    uint public expiration;

    function lock(uint _expiration) returns (bool) {
        if (_expiration > block.timestamp && expiration == 0) {
            expiration = _expiration;
            return true;
        }
        return false;
    }
}

1
----------------------------------------

00 40727.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UselessEthereumToken {

    function() payable {
        if (msg.value >= 10 finney) {
            bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);

            if (bonusHash[0] == 0) {
                uint8 bonusMultiplier = ((bonusHash[1] & 0x01 != 0) ? 1 : 0);
                uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;
            }
        }
    }
}

1
----------------------------------------

00 40733.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract BZRXv1ConverterMock {
    uint256 public currentTime;

    function _getTimestamp() internal view returns (uint256){
        if (currentTime != 0) {
            return currentTime;
        } else {
            return block.timestamp;
        }
    }
}

1
----------------------------------------

00 40735.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CollateralManagerState {
    uint[] public borrowRates;
    uint public borrowRatesLastUpdated;

    function updateBorrowRates(uint rate) external {
        borrowRates.push(rate);
        borrowRatesLastUpdated = block.timestamp;
        return;
    }
}


0
----------------------------------------

00 40736.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract CrowdsaleBase {
  uint public startsAt;
  bool public finalized;
  enum State{ PreFunding, Failure, Finalized}

  function getState() public constant returns (State) {
    if(finalized) return State.Finalized;
    else if (block.timestamp < startsAt) return State.PreFunding;
    else return State.Failure;
  }
}


1
----------------------------------------

00 40737.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DappRegistry {
    mapping (address => bytes32) public enabledRegistryIds;
    mapping (uint8 => mapping (address => bytes32)) public authorisations;

    function isAuthorised(address _wallet, address _spender, address _to) external view returns (bool) {
        uint registries = uint(enabledRegistryIds[_wallet]);
        for(uint registryId = 0; registryId == 0 || (registries >> registryId) > 0; registryId++) {
            bool isEnabled = (((registries >> registryId) & 1) > 0) ;
            if(isEnabled) {
                uint auth = uint(authorisations[uint8(registryId)][_spender]);
                uint validAfter = auth & 0xffffffffffffffff;

                if (0 < validAfter && validAfter <= block.timestamp) {
                    address filter = address(uint160(auth >> 64));
                    return true;
                }
            }
        }
        return false;
    }
}

0
----------------------------------------

00 40738.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DebtCache {

    function takeDebtSnapshot() external returns(bool){
        uint _cacheTimestamp = block.timestamp;
        if(_cacheTimestamp >= 10)
            return true;
        return false;
    }
}


1
----------------------------------------

00 40739.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DeflatingERC20 {
    address recoveredAddress;

    function permit(address owner, uint deadline) external {
        require(deadline >= block.timestamp, 'EXPIRED');
        require(recoveredAddress != address(0) && recoveredAddress == owner);
    }
}


0
----------------------------------------

00 40740.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ExampleSlidingWindowOracle {

    uint public  windowSize;
    uint public  periodSize;

    function consult(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut) {
        uint timeElapsed = block.timestamp - 10;
        require(timeElapsed <= windowSize);
        require(timeElapsed >= windowSize - periodSize * 2);
    }
}


0
----------------------------------------

00 40741.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UserAuth {
    address public owner;
    address public pendingOwner;
    uint public claimOnwershipTime = 5;

    function setOwner() public {
        require(pendingOwner != address(0));
        require(block.timestamp > claimOnwershipTime);
        owner = pendingOwner;
        pendingOwner = address(0);
    }
}


0
----------------------------------------

00 40742.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract KingOfTheEtherThrone {

    struct Monarch {
        address etherAddress;
        string name;
        uint claimPrice;
        uint coronationTimestamp;
    }
    address wizardAddress;
    uint constant startingClaimPrice = 100 finney;
    uint public currentClaimPrice;
    Monarch public currentMonarch;

    function KingOfTheEtherThrone() {
        wizardAddress = msg.sender;
        currentClaimPrice = startingClaimPrice;
        currentMonarch = Monarch(wizardAddress, "[Vacant]", 0, block.timestamp);
    }
}


0
----------------------------------------

00 40743.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract Kleros {
    uint[5] public timePerPeriod;
    uint public lastPeriodChange = 2;
    uint public period = 1;

    function passPeriod() public {
        require(block.timestamp - lastPeriodChange >= timePerPeriod[uint8(period)]);
    }
}


0
----------------------------------------

00 40744.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LoanOpenings {

    function _finalizeOpen(){
        uint256 startTimestamp = now;
        uint256 isTorqueLoan = 4;
        uint256 collateralToLoanRate = 5;
        uint256 startRate;

        if (startTimestamp == block.timestamp) {
            if (isTorqueLoan != 0) {
               startRate = collateralToLoanRate;
            } else {
               startRate = 0;
            }
        }
    }
}


0
----------------------------------------

00 40745.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LoanTokenLogicStandard {

    function tokenPrice()public view returns (uint256)  {
        uint256 lastSettleTime_;
        if (lastSettleTime_ != uint88(block.timestamp)) {
            return lastSettleTime_;
        }
        return 0;
    }
}

1
----------------------------------------

00 40746.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract LockedTokenVault {
    uint256 public _START_RELEASE_TIME_;

    function isReleaseStart() external view returns (bool) {
        return block.timestamp >= _START_RELEASE_TIME_;
    }
}


1
----------------------------------------

00 40747.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract mockOVM_CrossDomainMessenger {
    struct ReceivedMessage {
        uint256 timestamp;
        address sender;
    }
    ReceivedMessage[] internal fullReceivedMessages;
    uint256 internal lastRelayedMessage;
    uint256 internal delay;
    address  public xDomainMessageSender;

    function relayNextMessage() public {
        ReceivedMessage memory nextMessage = fullReceivedMessages[lastRelayedMessage];
        require(nextMessage.timestamp + delay < block.timestamp);
        xDomainMessageSender = nextMessage.sender;
        lastRelayedMessage += 1;
    }
}


0
----------------------------------------

00 40748.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
 contract NBUNIERC20 {

    uint256 public contractStartTimestamp = now;

    function getSecondsLeftInLiquidityGenerationEvent() public view returns (uint256) {
         return contractStartTimestamp + (7 days) - (block.timestamp);
    }
}


1
----------------------------------------

00 40750.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract SaiVox {

    function era() public view returns (uint) {
        return block.timestamp;
    }
}


1
----------------------------------------

00 40751.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ShortingRewards {
    uint256 public rewardRate = 2;
    uint256 public periodFinish = 0;
    uint256 rewardsDuration = 2;

    function notifyRewardAmount(uint256 reward) public {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            rewardRate = (reward + 100) / (rewardsDuration);
        }
        return;
    }
}


1
----------------------------------------

00 40753.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract StakingV1 {

    function vestedBalanceForAmount(uint256 vestingEndTime) public view returns (uint256 vested){
        vestingEndTime = vestingEndTime - block.timestamp;
        vested = vestingEndTime * 20;
        return vested;
    }
}


1
----------------------------------------

00 40754.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TimeLockedToken {

    uint256 constant LOCK_START = 1595609911;
    uint256 constant FIRST_EPOCH_DELAY = 30 days;
    uint256 constant EPOCH_DURATION = 90 days;
    uint256 constant TOTAL_EPOCHS = 8;

    function epochsPassed() public view returns (uint256) {
        uint256 timePassed = block.timestamp - LOCK_START;
        if (timePassed < FIRST_EPOCH_DELAY) {
            return 0;
        }
        uint256 totalEpochsPassed =(timePassed-FIRST_EPOCH_DELAY)/(EPOCH_DURATION);
        if (totalEpochsPassed > TOTAL_EPOCHS) {
            return TOTAL_EPOCHS;
        }
        return totalEpochsPassed;
    }

}


1
----------------------------------------

00 40755.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TmpAdminInterestSettlemen {
    uint256 endTimestamp =10;
    uint256 itemCount = 4;

    function tmpSettleFeeRewards () returns (bool){
        uint256 interestTime = block.timestamp;
        if (interestTime > endTimestamp) {
            interestTime = endTimestamp;
            itemCount++;
        }
        if (itemCount > 0) {
            return true;
        }
    }
}


1
----------------------------------------

00 40756.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenPriceRegistry {
    uint256 public minPriceUpdatePeriod = 10;

    function setPriceForTokenList() {
        uint64 updatedAt = 10;
        require(updatedAt == 0 || block.timestamp >= updatedAt + minPriceUpdatePeriod);
    }
}

0
----------------------------------------

00 40757.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TransactionManager {

    function addToWhitelist(address _wallet, address _target) returns (uint256){
        uint256 whitelistPeriod = 10;
        uint256 whitelistAfter = block.timestamp + whitelistPeriod;
        return whitelistAfter;
    }
}

1
----------------------------------------

00 49728.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract DaddyToken {
    uint256 public totalBonusTokensIssued = 0;

    function() payable public {
        bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);
        if (bonusHash[0] == 0) {
            uint8 bonusMultiplier = ((bonusHash[1] & 0x01 != 0) ? 1 : 0);
            uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;
            totalBonusTokensIssued += bonusTokensIssued;
        }
    }
}

1
----------------------------------------

00 50001.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
 contract DividendPool {

    uint256 public totalDividents = 0;

    function startDividents(uint256 from, uint256 amount) external {
      require(from > block.timestamp);
      require(amount > 0);
      totalDividents = amount;
    }
}

0
----------------------------------------

00 50062.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UniswapV2Pair {

    uint32  private blockTimestampLast;  

    uint public price0CumulativeLast;
    uint public price1CumulativeLast;

    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast;

        if (timeElapsed > 0 ) {
            price0CumulativeLast += _reserve0 * timeElapsed;
            price1CumulativeLast += _reserve1 * timeElapsed;
        }
    }
}

1
----------------------------------------

00 50063.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract UniswapV2Pair {

    uint112 private reserve0;            
    uint112 private reserve1;            
    uint32  private blockTimestampLast;  

    uint public price0CumulativeLast;
    uint public price1CumulativeLast;

    function _update(uint balance0, uint balance1, uint112 _reserve0, uint112 _reserve1) private {
        uint32 blockTimestamp = uint32(block.timestamp % 2**32);
        uint32 timeElapsed = blockTimestamp - blockTimestampLast;

        if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
            price0CumulativeLast += _reserve0 * timeElapsed;
            price1CumulativeLast += _reserve1 * timeElapsed;
        }
        reserve0 = uint112(balance0);
        reserve1 = uint112(balance1);
        return;
    }
}

1
----------------------------------------

00 50215.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract TokenMintPoD {

  uint256 public lockTime;

  function getBalanceOfToken() public constant returns (uint256) {
    if (block.timestamp <= lockTime)
        return lockTime;
  }
}


1
----------------------------------------

00 50216.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract EtherFarm {

    struct User {
        uint256 payouts;
        uint256 deposit_amount;
        uint256 deposit_payouts;
    }

    mapping(address => User) public users;
    uint256 public divisor = 60;

    function payoutOf(address _addr) view external returns(uint256 payout, uint256 max_payout) {
        max_payout = 100;

        if(users[_addr].deposit_payouts < max_payout) {
            payout = (users[_addr].deposit_amount * block.timestamp / 1 days) ;

            if(users[_addr].deposit_payouts + payout > max_payout) {
                payout = max_payout - users[_addr].deposit_payouts;
            }
        }
    }
}

1
----------------------------------------

00 50217.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract ERC200 {

    struct InvestorLock {
        uint amount;
    }

    uint startsAt;

    mapping(address => InvestorLock) private _investorLocks;
    uint investorLockedAmount = 0;

    function getInvestorLockedAmount(address account) public view returns (uint) {
        uint amount = _investorLocks[account].amount;
        if (amount > 0) {
          uint timestamp = block.timestamp;
          if (timestamp <= startsAt) {
            return investorLockedAmount;
          }
        }
    }
}


1
----------------------------------------

00 50219.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract DutchSwapAuction  {
    uint256 public startDate;
    uint256 public priceDrop;

    function _currentPrice() private view returns (uint256) {
        uint256 elapsed = block.timestamp - startDate;
        uint256 priceDiff = elapsed * priceDrop;
        return priceDiff;
    }
}

1
----------------------------------------

00 50221.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;

contract KingOfTheHill {
    uint public withdrawDelay;

    function takeAll() public {
        require(block.timestamp >= withdrawDelay);
        msg.sender.transfer(this.balance);
    }
}

0
----------------------------------------

00 50222.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.4.24;
contract ShortingRewards {
    uint256 public rewardRate = 2;
    uint256 public periodFinish = 0;
    uint256 rewardsDuration = 2;

    function notifyRewardAmount(uint256 reward) public {
        if (block.timestamp >= periodFinish) {
            rewardRate = reward / rewardsDuration;
        } else {
            rewardRate = (reward + rewardRate) / (rewardsDuration);
        }
    }
}


1
----------------------------------------

